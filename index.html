<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D3-DNA Diffusion Visualizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/h5wasm@0.4.9/dist/esm/hdf5.js"></script>
    <script src="bundle.js" type="text/javascript"></script>
    <script src="memesuite-lite-js/memesuite-lite.js" type="text/javascript"></script>
    <style>
        /* Theme variables */
        :root {
            /* Dark theme (default) */
            --bg-primary: #0a0a0a;
            --bg-secondary: #1a1a1a;
            --bg-tertiary: #1e1e1e;
            --bg-quaternary: #0f0f0f;
            --text-primary: #ffffff;
            --text-secondary: #888;
            --accent-primary: #00d4ff;
            --border-color: #333;
            --input-bg: #333;
            --input-hover-bg: #555;
            --base-a-color: #ff6b6b;
            --base-c-color: #4ecdc4;
            --base-g-color: #45b7d1;
            --base-t-color: #96ceb4;
        }
        
        [data-theme="light"] {
            /* Light theme */
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-tertiary: #e9ecef;
            --bg-quaternary: #f5f5f5;
            --text-primary: #212529;
            --text-secondary: #6c757d;
            --accent-primary: #0056b3;
            --border-color: #dee2e6;
            --input-bg: #e9ecef;
            --input-hover-bg: #dee2e6;
            --base-a-color: #d63031;
            --base-c-color: #00b894;
            --base-g-color: #0984e3;
            --base-t-color: #00a085;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        .container {
            display: grid;
            grid-template-columns: 280px 1fr 350px;
            grid-template-rows: 60px 1fr 80px;
            height: 100vh;
            gap: 1px;
            background: var(--bg-secondary);
        }
        
        .container.collapsed-tomtom {
            grid-template-columns: 280px 1fr 0px;
        }
        
        .container.collapsed-tomtom .tomtom-panel {
            transform: translateX(100%);
            transition: transform 0.3s ease;
            border-left: none;
        }
        
        .container.collapsed-tomtom .tomtom-panel.hover-peek {
            position: fixed;
            top: 50%;
            right: 0;
            width: 40px;
            height: 120px;
            transform: translateY(-50%);
            z-index: 1001;
            border-radius: 8px 0 0 8px;
            border: 1px solid var(--border-color);
            border-right: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .container.collapsed-tomtom .tomtom-panel.hover-peek:hover {
            width: 50px;
            background: var(--input-hover-bg);
        }
        
        .hover-tab-content {
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            user-select: none;
            white-space: nowrap;
        }
        
        .header {
            grid-column: 1 / -1;
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            padding: 0 20px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .header h1 {
            font-size: 20px;
            font-weight: 600;
            color: var(--accent-primary);
        }
        
        .sidebar {
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
        }
        
        .main-panel {
            background: var(--bg-quaternary);
            overflow: hidden;
            padding: 16px;
            display: flex;
            flex-direction: column;
            min-width: 0; /* Allow flex items to shrink below content size */
            max-width: 100%;
        }
        
        .controls {
            grid-column: 1 / -1;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 15px;
            position: sticky;
            bottom: 0;
            z-index: 100;
        }
        
        /* Sidebar Styles */
        .sidebar-section {
            padding: 15px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .sidebar-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 10px;
        }
        
        .sample-list {
            flex: 1;
            overflow-y: auto;
            max-height: var(--sidebar-content-height);
            padding-bottom: 120px;
        }
        
        .sample-item {
            padding: 8px 15px;
            cursor: pointer;
            border-radius: 4px;
            margin-bottom: 2px;
            transition: all 0.2s ease;
            font-size: 13px;
            border: 1px solid transparent;
        }
        
        .sample-item:hover {
            background: var(--input-hover-bg);
            border-color: var(--border-color);
            transform: translateX(2px);
        }
        
        .sample-item.active {
            background: var(--accent-primary);
            color: var(--bg-primary);
            border-color: var(--accent-primary);
            font-weight: 600;
            transform: translateX(4px);
        }
        
        /* Main Panel Styles */
        .visualization-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto auto auto auto;
            gap: 15px;
            max-height: var(--main-content-height);
            overflow-y: auto;
            width: 100%;
            max-width: 100%;
        }
        
        .viz-section {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 14px;
            border: 1px solid var(--border-color);
            transition: all 0.2s ease;
            min-width: 0; /* Allow flex items to shrink below content size */
            max-width: 100%;
        }
        
        .viz-section:hover {
            border-color: var(--accent-primary);
            box-shadow: 0 2px 8px rgba(0, 212, 255, 0.1);
        }
        
        .viz-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--accent-primary);
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .sequence-display {
            grid-column: 1 / -1;
        }
        
        .score-matrix-section {
            grid-column: 1 / -1;
        }
        
        .sequence-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
            max-width: 100%;
            min-width: 0;
        }
        
        .sequence-scroll-container {
            overflow-x: auto;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-primary);
        }
        
        .sequence-wrapper {
            display: flex;
            flex-direction: column;
            width: max-content;
            min-width: 100%;
            max-width: 100%;
        }
        
        .position-axis {
            font-family: 'Courier New', monospace;
            font-size: 10px;
            color: var(--text-secondary);
            padding: 4px 10px 8px 10px;
            white-space: nowrap;
            border-top: 1px solid var(--border-color);
            margin-top: 4px;
        }
        
        .sequence-section {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .sequence-label {
            font-size: 11px;
            font-weight: 600;
            color: var(--accent-primary);
            text-transform: uppercase;
        }
        
        .sequence-text {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.6;
            white-space: nowrap;
            background: transparent;
            padding: 8px 10px;
            border: none;
            overflow: visible;
        }
        
        .sequence-text-single {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.6;
            white-space: nowrap;
            background: var(--bg-primary);
            padding: 10px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            height: 60px;
            overflow-x: auto;
            overflow-y: hidden;
        }
        
        .base-A { color: var(--base-a-color); }
        .base-C { color: var(--base-c-color); }
        .base-G { color: var(--base-g-color); }
        .base-T { color: var(--base-t-color); }
        
        .nucleotide-highlight {
            background: var(--accent-primary);
            color: var(--bg-primary);
            border-radius: 3px;
            padding: 0 2px;
            box-shadow: 0 0 8px rgba(0, 212, 255, 0.4);
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .matrix-controls {
            margin-bottom: 10px;
        }
        
        .toggle-btn {
            background: var(--input-bg);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-right: 10px;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        
        .toggle-btn:hover {
            border-color: var(--accent-primary);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .toggle-btn.active {
            background: var(--accent-primary);
            color: var(--bg-primary);
        }
        
        .matrix-display {
            overflow-x: auto;
            max-height: 250px; /* Much taller to accommodate larger logo */
        }
        
        .score-matrix-section.dual-mode {
            max-height: 500px; /* Expanded height for dual matrix view - heatmap */
        }
        
        .score-matrix-section.dual-mode.logo-mode {
            max-height: 650px; /* Even taller for dual logo view */
        }
        
        .score-matrix-section.dual-mode .matrix-display {
            max-height: 450px; /* Expanded height for dual matrix container - heatmap */
            overflow-y: auto; /* Allow scrolling if content exceeds */
            overflow-x: visible; /* Allow horizontal overflow for wide logos */
        }
        
        .score-matrix-section.dual-mode.logo-mode .matrix-display {
            max-height: 600px; /* Even taller container for dual logo view */
            overflow-x: auto; /* Allow horizontal scrolling for wide logos */
        }
        
        .score-matrix-section .matrix-display {
            overflow-x: auto; /* Allow horizontal scrolling for wide content */
        }
        
        .heatmap-container {
            display: block;
            width: 100%;
            overflow-x: auto;
            max-width: 100%;
        }
        
        .logo-container {
            display: inline-block;
            min-width: 100%;
            width: max-content; /* Allow container to expand to content width */
        }
        
        .heatmap-legend {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin-top: 8px;
            gap: 4px;
            font-size: 10px;
        }
        
        .dual-matrix-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .matrix-section {
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 12px;
            background: var(--bg-primary);
            overflow-x: auto; /* Allow horizontal scrolling if content is wider */
            min-height: 200px; /* Ensure minimum height */
            width: 100%;
            max-width: 100%;
            min-width: 0;
        }
        
        .matrix-subtitle {
            font-size: 12px;
            font-weight: 600;
            color: var(--accent-primary);
            margin-bottom: 8px;
            text-align: center;
        }
        
        .legend-gradient {
            width: 200px;
            height: 10px;
            border-radius: 5px;
            border: 1px solid var(--border-color);
        }
        
        .legend-labels {
            display: flex;
            justify-content: space-between;
            width: 202px;
            color: var(--text-secondary);
        }
        
        .tooltip {
            position: absolute;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 11px;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .chart-container {
            height: var(--chart-height);
            position: relative;
            width: 100%;
            max-width: 100%;
        }
        
        /* Control Styles */
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .control-btn {
            background: var(--input-bg);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            width: 36px;
            height: 36px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        
        .control-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: var(--accent-primary);
            border-radius: 50%;
            transition: all 0.3s ease;
            transform: translate(-50%, -50%);
            z-index: 0;
        }
        
        .control-btn:hover::before {
            width: 100%;
            height: 100%;
        }
        
        .control-btn > * {
            position: relative;
            z-index: 1;
        }
        
        .control-btn:hover {
            background: var(--accent-primary);
            color: var(--bg-primary);
        }
        
        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .step-slider {
            flex: 1;
            height: 4px;
            background: var(--input-bg);
            border-radius: 2px;
            outline: none;
            margin: 0 15px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .step-slider::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent-primary);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .step-slider::-webkit-slider-thumb:hover {
            width: 20px;
            height: 20px;
            box-shadow: 0 0 0 4px rgba(0, 212, 255, 0.2);
        }
        
        .step-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--accent-primary);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            transition: all 0.2s ease;
        }
        
        .step-info {
            font-size: 12px;
            color: var(--text-secondary);
            min-width: 120px;
        }
        
        .theme-toggle {
            background: var(--input-bg);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            width: 36px;
            height: 36px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            font-size: 16px;
        }
        
        .theme-toggle:hover {
            background: var(--input-hover-bg);
        }
        
        .file-input {
            background: var(--accent-primary);
            color: var(--bg-primary);
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        
        .file-input::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s ease;
        }
        
        .file-input:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 212, 255, 0.3);
        }
        
        .file-input:hover::before {
            left: 100%;
        }
        
        /* Scrollbar Styles */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--input-bg);
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-primary);
            box-shadow: 0 0 0 1px rgba(0, 212, 255, 0.3);
        }
        
        .stats-display {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 5px;
        }
        
        .hidden {
            display: none !important;
        }
        
        .loading {
            text-align: center;
            color: var(--text-secondary);
            padding: 40px;
            font-size: 14px;
        }
        
        /* Override LogoJS colors for theme support */
        [data-theme="dark"] .logo-container svg text {
            fill: #ffffff !important;
        }
        
        [data-theme="dark"] .logo-container svg line {
            stroke: #ffffff !important;
        }
        
        [data-theme="light"] .logo-container svg text {
            fill: #6c757d !important;
        }
        
        [data-theme="light"] .logo-container svg line {
            stroke: #6c757d !important;
        }
        
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .viz-section {
            animation: fadeInUp 0.6s ease-out;
        }
        
        .viz-section:nth-child(1) { animation-delay: 0.1s; }
        .viz-section:nth-child(2) { animation-delay: 0.2s; }
        .viz-section:nth-child(3) { animation-delay: 0.3s; }
        .viz-section:nth-child(4) { animation-delay: 0.4s; }
        .viz-section:nth-child(5) { animation-delay: 0.5s; }
        .viz-section:nth-child(6) { animation-delay: 0.6s; }
        
        /* Responsive Design */
        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 240px 1fr;
            }
            
            .visualization-grid {
                gap: 15px;
            }
        }
        
        @media (max-width: 1024px) {
            .container {
                grid-template-columns: 220px 1fr;
            }
            
            .main-panel {
                padding: 12px;
            }
            
            .visualization-grid {
                grid-template-columns: 1fr 1fr;
                grid-template-rows: auto auto auto auto;
                gap: 10px;
            }
        }
        
        @media (max-width: 900px) {
            .visualization-grid {
                grid-template-columns: 1fr;
                grid-template-rows: repeat(6, auto);
                gap: 10px;
            }
            
            .sequence-display,
            .score-matrix-section {
                grid-column: 1;
            }
        }
        
        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: 60px auto 1fr 80px;
            }
            
            .sidebar {
                grid-row: 2;
                max-height: 200px;
                overflow-y: auto;
            }
            
            .main-panel {
                grid-row: 3;
                padding: 8px;
            }
            
            .controls {
                grid-row: 4;
                flex-wrap: wrap;
                padding: 10px;
                gap: 8px;
            }
            
            .step-slider {
                flex: 1 1 100%;
                margin: 5px 0;
            }
            
            .sequence-container {
                gap: 10px;
            }
            
            .sequence-text {
                font-size: 10px;
                max-height: 100px;
            }
        }
        
        @media (max-width: 480px) {
            .header {
                padding: 0 10px;
            }
            
            .header h1 {
                font-size: 16px;
            }
            
            .file-input {
                padding: 6px 12px;
                font-size: 11px;
            }
            
            .control-btn {
                width: 32px;
                height: 32px;
            }
            
            .viz-title {
                font-size: 12px;
            }
            
            .viz-section {
                padding: 10px;
            }
        }
        
        /* TOMTOM Panel Styles */
        .tomtom-panel {
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: transform 0.3s ease;
        }
        
        
        .tomtom-header {
            background: var(--bg-tertiary);
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .tomtom-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--accent-primary);
            margin: 0;
        }
        
        .tomtom-toggle {
            background: var(--input-bg);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            width: 32px;
            height: 32px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            font-size: 16px;
        }
        
        .tomtom-toggle:hover {
            background: var(--input-hover-bg);
        }
        
        .tomtom-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            padding-bottom: 120px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .tomtom-section {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 15px;
        }
        
        .tomtom-section-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--accent-primary);
            margin-bottom: 12px;
        }
        
        .selection-info {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px;
            font-size: 12px;
            margin-bottom: 10px;
        }
        
        .selection-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .selection-btn {
            background: var(--input-bg);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s ease;
        }
        
        .selection-btn:hover {
            background: var(--input-hover-bg);
        }
        
        .selection-btn.active {
            background: var(--accent-primary);
            color: var(--bg-primary);
            border-color: var(--accent-primary);
        }
        
        .upload-area {
            border: 2px dashed var(--border-color);
            border-radius: 6px;
            padding: 20px;
            text-align: center;
            background: var(--bg-tertiary);
            transition: all 0.2s ease;
            cursor: pointer;
            margin-bottom: 15px;
        }
        
        .upload-area:hover, .upload-area.dragover {
            border-color: var(--accent-primary);
            background: var(--bg-quaternary);
        }
        
        .upload-area.has-file {
            border-color: var(--success-color, #4ecdc4);
            background: var(--bg-quaternary);
        }
        
        .upload-icon {
            font-size: 24px;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }
        
        .upload-text {
            color: var(--text-secondary);
            font-size: 12px;
            margin-bottom: 5px;
        }
        
        .file-name {
            color: var(--success-color, #4ecdc4);
            font-weight: 500;
            font-size: 11px;
        }
        
        .param-group {
            margin-bottom: 15px;
        }
        
        .param-label {
            font-size: 11px;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 6px;
            display: block;
        }
        
        .param-input {
            width: 100%;
            background: var(--input-bg);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 6px 8px;
            font-size: 11px;
        }
        
        .param-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 2px rgba(0, 212, 255, 0.1);
        }
        
        .param-slider {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .param-range {
            flex: 1;
            height: 3px;
            background: var(--input-bg);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }
        
        .param-range::-webkit-slider-thumb {
            appearance: none;
            width: 12px;
            height: 12px;
            background: var(--accent-primary);
            border-radius: 50%;
            cursor: pointer;
        }
        
        .param-value {
            font-size: 10px;
            color: var(--text-secondary);
            min-width: 40px;
            text-align: right;
        }
        
        .run-tomtom-btn {
            width: 100%;
            background: var(--accent-primary);
            color: var(--bg-primary);
            border: none;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        
        .run-tomtom-btn:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 212, 255, 0.3);
        }
        
        .run-tomtom-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .tomtom-results {
            max-height: 300px;
            overflow-y: auto;
        }
        
        .result-item {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .result-item:hover {
            background: var(--input-hover-bg);
            border-color: var(--accent-primary);
        }
        
        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        
        .result-name {
            font-weight: 500;
            font-size: 12px;
            color: var(--text-primary);
        }
        
        .result-score {
            font-size: 11px;
            color: var(--accent-primary);
        }
        
        .result-details {
            font-size: 10px;
            color: var(--text-secondary);
            line-height: 1.4;
        }
        
        /* Selection overlay styles */
        .matrix-selection-overlay {
            position: absolute;
            background: rgba(0, 212, 255, 0.2);
            border: 2px solid var(--accent-primary);
            border-radius: 2px;
            pointer-events: none;
            z-index: 10;
        }
        
        .heatmap-container {
            position: relative;
        }
        
        .selection-mode .heatmap-container {
            cursor: crosshair;
        }
        
        /* Selection highlights in matrix */
        .matrix-cell-selected {
            stroke: var(--accent-primary) !important;
            stroke-width: 2px !important;
            stroke-opacity: 0.8 !important;
        }
        
        .matrix-position-selected {
            background: rgba(0, 212, 255, 0.3) !important;
        }
        
        .success-color { color: #4ecdc4; }
        .warning-color { color: #ffa726; }
        .error-color { color: #ef5350; }
        
        /* Enhanced results table styles */
        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .results-header h4 {
            margin: 0;
            color: var(--text-primary);
        }
        
        .export-btn {
            background: var(--accent-primary);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }
        
        .export-btn:hover {
            background: var(--accent-secondary);
        }
        
        .results-table-container {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 15px;
        }
        
        .results-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }
        
        .results-table th {
            background: var(--card-bg);
            color: var(--text-primary);
            font-weight: 600;
            padding: 12px 8px;
            text-align: left;
            border-bottom: 2px solid var(--border-color);
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .results-table td {
            padding: 10px 8px;
            border-bottom: 1px solid var(--border-color);
            vertical-align: middle;
        }
        
        .result-row:hover {
            background: var(--hover-bg);
        }
        
        .motif-name {
            font-weight: 500;
            color: var(--accent-primary);
        }
        
        .p-value {
            font-family: monospace;
            color: var(--text-secondary);
        }
        
        .strand.positive {
            color: #4caf50;
            font-weight: bold;
        }
        
        .strand.negative {
            color: #f44336;
            font-weight: bold;
        }
        
        .alignment {
            font-family: monospace;
            font-size: 11px;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .detail-btn {
            background: var(--button-bg);
            color: var(--button-color);
            border: 1px solid var(--border-color);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }
        
        .detail-btn:hover {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
        }
        
        .motif-detail-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            z-index: 1000;
            width: 450px;
            max-height: 70vh;
            overflow: hidden;
            cursor: move;
        }
        
        .motif-detail-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(5px);
            z-index: -1;
            border-radius: 12px;
        }
        
        .detail-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-secondary);
        }
        
        .detail-header h5 {
            margin: 0;
            color: var(--text-primary);
        }
        
        .detail-header button {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: var(--text-secondary);
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.2s;
        }
        
        .detail-header button:hover {
            background: var(--input-hover-bg);
        }
        
        .detail-content {
            padding: 20px;
            max-height: calc(70vh - 80px);
            overflow-y: auto;
            background: var(--bg-primary);
        }
        
        .logo-comparison {
            display: flex;
            flex-direction: column;
            gap: 30px;
            align-items: center;
        }
        
        .logo-container {
            text-align: center;
            width: 100%;
            max-width: 350px;
        }
        
        .logo-container h6 {
            margin: 0 0 15px 0;
            color: var(--text-primary);
            font-weight: 600;
        }
        
        .motif-logo {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            background: var(--bg-secondary);
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            overflow-x: auto;
        }
        
        .no-results {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }
        
        .no-results-icon {
            font-size: 48px;
            margin-bottom: 20px;
        }
        
        .no-results h4 {
            margin: 0 0 10px 0;
            color: var(--text-primary);
        }
        
        .no-results p {
            margin: 0;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container collapsed-tomtom">
        <header class="header">
            <h1>🧬 D3-DNA Diffusion Visualizer</h1>
            <div style="margin-left: auto; display: flex; align-items: center; gap: 15px;">
                <button class="theme-toggle" id="themeToggle" title="Toggle Light/Dark Mode">
                    <span id="themeIcon">☀️</span>
                </button>
                <input type="file" id="fileInput" accept=".h5,.hdf5,.json" style="display: none;">
                <button class="file-input" onclick="document.getElementById('fileInput').click()">
                    Load Data
                </button>
            </div>
        </header>
        
        <aside class="sidebar">
            <div class="sidebar-section">
                <div class="sidebar-title">Dataset Info</div>
                <div id="datasetInfo" class="stats-display">No data loaded</div>
            </div>
            
            <div class="sidebar-section">
                <div class="sidebar-title">Samples</div>
            </div>
            
            <div class="sample-list" id="sampleList">
                <div class="loading">Load a data file to begin</div>
            </div>
        </aside>
        
        <main class="main-panel">
            <div id="mainContent" class="hidden">
                <div class="visualization-grid">
                    <div class="viz-section sequence-display">
                        <div class="viz-title">
                            DNA Sequences
                            <div class="stats-display" id="sequenceStats"></div>
                        </div>
                        <div class="sequence-container">
                            <div id="sequenceScrollContainer" class="sequence-scroll-container">
                                <div class="sequence-wrapper">
                                    <div class="sequence-section" id="originalSequenceSection" style="display: none;">
                                        <div class="sequence-label">Original Sequence</div>
                                        <div id="originalSequenceText" class="sequence-text"></div>
                                    </div>
                                    <div class="sequence-section">
                                        <div class="sequence-label">Generated Sequence</div>
                                        <div id="sequenceText" class="sequence-text"></div>
                                    </div>
                                    <div id="positionAxis" class="position-axis"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="viz-section score-matrix-section">
                        <div class="viz-title">
                            <span id="matrixTitle">Score Matrix</span>
                            <div class="matrix-controls">
                                <button class="toggle-btn active" data-type="score">Score</button>
                                <button class="toggle-btn" data-type="prob">Prob</button>
                                <button class="toggle-btn" data-type="both">Both</button>
                                <button class="toggle-btn active" data-mode="heatmap">Heatmap</button>
                                <button class="toggle-btn" data-mode="logo">Logo</button>
                            </div>
                        </div>
                        <div class="matrix-display">
                            <div id="singleMatrixContainer" class="single-matrix-container">
                                <div id="heatmapContainer" class="heatmap-container"></div>
                                <div id="logoContainer" class="logo-container hidden"></div>
                                <div id="heatmapLegend" class="heatmap-legend"></div>
                            </div>
                            <div id="dualMatrixContainer" class="dual-matrix-container hidden">
                                <div class="matrix-section">
                                    <h4 class="matrix-subtitle">Score Matrix</h4>
                                    <div id="scoreHeatmapContainer" class="heatmap-container"></div>
                                    <div id="scoreLogoContainer" class="logo-container hidden"></div>
                                    <div id="scoreHeatmapLegend" class="heatmap-legend"></div>
                                </div>
                                <div class="matrix-section">
                                    <h4 class="matrix-subtitle">Probability Matrix</h4>
                                    <div id="probHeatmapContainer" class="heatmap-container"></div>
                                    <div id="probLogoContainer" class="logo-container hidden"></div>
                                    <div id="probHeatmapLegend" class="heatmap-legend"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="viz-section">
                        <div class="viz-title">Oracle MSE vs Steps</div>
                        <div class="chart-container">
                            <canvas id="mseChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="viz-section">
                        <div class="viz-title">Nucleotide Changes vs Steps</div>
                        <div class="chart-container">
                            <canvas id="changesChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="viz-section">
                        <div class="viz-title">Noise Level vs Steps</div>
                        <div class="chart-container">
                            <canvas id="noiseChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="viz-section">
                        <div class="viz-title">Average Score Change vs Steps</div>
                        <div class="chart-container">
                            <canvas id="rateChart"></canvas>
                        </div>
                    </div>
                    
                    <!-- Prediction plot sections will be dynamically inserted after this point -->
                </div>
            </div>
            
            <div id="placeholderContent" class="loading">
                <h2>Welcome to D3-DNA Diffusion Visualizer</h2>
                <p>Load your visualization data to begin exploring the diffusion process</p>
                <br>
                <div style="text-align: left; max-width: 600px; margin: 0 auto; font-size: 12px; color: #888;">
                    <p><strong>Supported formats:</strong></p>
                    <ul style="margin-left: 20px;">
                        <li><strong>JSON</strong> - Recommended for browser compatibility</li>
                        <li><strong>HDF5</strong> (.h5, .hdf5) - Native browser support</li>
                    </ul>
                    <br>
                </div>
            </div>
        </main>
        
        <!-- TOMTOM Panel -->
        <div class="tomtom-panel collapsed" id="tomtomPanel">
            <div class="tomtom-header">
                <h3 class="tomtom-title">TOMTOM Analysis</h3>
                <button class="tomtom-toggle" id="tomtomToggle" title="Toggle TOMTOM Panel">
                    <span id="tomtomToggleIcon">▶</span>
                </button>
            </div>
            
            <div class="tomtom-content">
                <!-- Selection Section -->
                <div class="tomtom-section">
                    <div class="tomtom-section-title">Matrix Selection</div>
                    
                    <div class="selection-info" id="selectionInfo">
                        <div id="selectionStatus">Click and drag on the matrix to select a region</div>
                        <div id="selectionDetails" style="margin-top: 5px; display: none;">
                            Selection: Position <span id="selectionStart">-</span> to <span id="selectionEnd">-</span> 
                            (<span id="selectionLength">0</span> positions)
                        </div>
                    </div>
                    
                    <div class="selection-controls">
                        <button class="selection-btn" id="enableSelection">Enable Selection</button>
                        <button class="selection-btn" id="clearSelection">Clear</button>
                        <button class="selection-btn" id="selectAll">Select All</button>
                    </div>
                </div>
                
                <!-- Database Upload Section -->
                <div class="tomtom-section">
                    <div class="tomtom-section-title">Motif Database</div>
                    
                    <div class="upload-area" id="databaseUpload" onclick="document.getElementById('databaseFile').click()">
                        <div class="upload-icon">📁</div>
                        <div class="upload-text">
                            Click to upload MEME database file
                            <br><small>(.meme, .txt formats)</small>
                        </div>
                        <div class="file-name" id="databaseFileName"></div>
                    </div>
                    <input type="file" id="databaseFile" accept=".meme,.txt" style="display: none;">
                </div>
                
                <!-- Parameters Section -->
                <div class="tomtom-section">
                    <div class="tomtom-section-title">Parameters</div>
                    
                    <div class="param-group">
                        <label class="param-label">P-value Threshold</label>
                        <div class="param-slider">
                            <input type="range" class="param-range" id="pvalueThreshold" 
                                   min="-5" max="1" step="0.1" value="-3">
                            <span class="param-value" id="pvalueValue">1.0e-3</span>
                        </div>
                    </div>
                    
                    <div class="param-group">
                        <label class="param-label">Max Results</label>
                        <input type="number" class="param-input" id="maxResults" value="10" min="1" max="100">
                    </div>
                    
                    <div class="param-group">
                        <label class="param-label">
                            <input type="checkbox" id="includeRC" checked> Include reverse complement
                        </label>
                    </div>
                    
                    <button class="run-tomtom-btn" id="runTomtom" disabled>Run TOMTOM Analysis</button>
                </div>
                
                <!-- Results Section -->
                <div class="tomtom-section" id="resultsSection" style="display: none;">
                    <div class="tomtom-section-title">Results</div>
                    
                    <div class="tomtom-results" id="tomtomResults">
                        <!-- Results will be populated here -->
                    </div>
                    
                    <button class="selection-btn" id="exportResults" style="margin-top: 10px; width: 100%;">
                        Export Results
                    </button>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <button class="control-btn" id="playBtn" title="Play/Pause">
                    <span id="playIcon">▶</span>
                </button>
                <button class="control-btn" id="prevBtn" title="Previous Step">⏮</button>
                <button class="control-btn" id="nextBtn" title="Next Step">⏭</button>
            </div>
            
            <input type="range" id="stepSlider" class="step-slider" min="0" max="0" value="0">
            
            <div class="step-info">
                <span id="stepInfo">Step: 0 / 0</span>
            </div>
            
            <div class="control-group">
                <label style="font-size: 12px; color: #888;">Speed:</label>
                <input type="range" id="speedSlider" min="1" max="10" value="3" style="width: 80px;">
            </div>
        </div>
    </div>
    
    <!-- Tooltip for heatmap hover -->
    <div id="tooltip" class="tooltip"></div>

    <script>
        class DNADiffusionVisualizer {
            constructor() {
                this.data = null;
                this.currentSample = 0;
                this.currentStep = 0;
                this.isPlaying = false;
                this.playInterval = null;
                this.charts = {};
                this.matrixMode = 'heatmap';
                this.matrixType = 'score'; // 'score' or 'prob'
                this.theme = 'dark'; // Default theme
                this.highlightedPosition = null; // Track highlighted nucleotide position
                this.isScrollingSyncronized = false; // Prevent infinite scroll loop
                this.scrollHandlers = null; // Store scroll event handlers for cleanup
                
                // TOMTOM-related properties
                this.selectionMode = false;
                this.isSelecting = false;
                this.selectionStart = null;
                this.selectionEnd = null;
                this.selectedRange = null;
                this.uploadedDatabase = null;
                this.tomtomResults = null;
                
                this.initializeElements();
                this.setupEventListeners();
                this.initializeCharts();
                this.initializeTheme();
                this.setupViewportSizing();
            }
            
            initializeElements() {
                this.elements = {
                    fileInput: document.getElementById('fileInput'),
                    sampleList: document.getElementById('sampleList'),
                    datasetInfo: document.getElementById('datasetInfo'),
                    mainContent: document.getElementById('mainContent'),
                    placeholderContent: document.getElementById('placeholderContent'),
                    sequenceText: document.getElementById('sequenceText'),
                    originalSequenceText: document.getElementById('originalSequenceText'),
                    originalSequenceSection: document.getElementById('originalSequenceSection'),
                    sequenceScrollContainer: document.getElementById('sequenceScrollContainer'),
                    sequenceStats: document.getElementById('sequenceStats'),
                    positionAxis: document.getElementById('positionAxis'),
                    // Single matrix containers
                    singleMatrixContainer: document.getElementById('singleMatrixContainer'),
                    heatmapContainer: document.getElementById('heatmapContainer'),
                    logoContainer: document.getElementById('logoContainer'),
                    heatmapLegend: document.getElementById('heatmapLegend'),
                    // Dual matrix containers
                    dualMatrixContainer: document.getElementById('dualMatrixContainer'),
                    scoreHeatmapContainer: document.getElementById('scoreHeatmapContainer'),
                    scoreLogoContainer: document.getElementById('scoreLogoContainer'),
                    scoreHeatmapLegend: document.getElementById('scoreHeatmapLegend'),
                    probHeatmapContainer: document.getElementById('probHeatmapContainer'),
                    probLogoContainer: document.getElementById('probLogoContainer'),
                    probHeatmapLegend: document.getElementById('probHeatmapLegend'),
                    matrixTitle: document.getElementById('matrixTitle'),
                    stepSlider: document.getElementById('stepSlider'),
                    stepInfo: document.getElementById('stepInfo'),
                    playBtn: document.getElementById('playBtn'),
                    playIcon: document.getElementById('playIcon'),
                    prevBtn: document.getElementById('prevBtn'),
                    nextBtn: document.getElementById('nextBtn'),
                    speedSlider: document.getElementById('speedSlider'),
                    themeToggle: document.getElementById('themeToggle'),
                    themeIcon: document.getElementById('themeIcon'),
                    // TOMTOM elements
                    tomtomPanel: document.getElementById('tomtomPanel'),
                    tomtomToggle: document.getElementById('tomtomToggle'),
                    tomtomToggleIcon: document.getElementById('tomtomToggleIcon'),
                    enableSelection: document.getElementById('enableSelection'),
                    clearSelection: document.getElementById('clearSelection'),
                    selectAll: document.getElementById('selectAll'),
                    selectionInfo: document.getElementById('selectionInfo'),
                    selectionStatus: document.getElementById('selectionStatus'),
                    selectionDetails: document.getElementById('selectionDetails'),
                    selectionStart: document.getElementById('selectionStart'),
                    selectionEnd: document.getElementById('selectionEnd'),
                    selectionLength: document.getElementById('selectionLength'),
                    databaseUpload: document.getElementById('databaseUpload'),
                    databaseFile: document.getElementById('databaseFile'),
                    databaseFileName: document.getElementById('databaseFileName'),
                    pvalueThreshold: document.getElementById('pvalueThreshold'),
                    pvalueValue: document.getElementById('pvalueValue'),
                    maxResults: document.getElementById('maxResults'),
                    includeRC: document.getElementById('includeRC'),
                    runTomtom: document.getElementById('runTomtom'),
                    resultsSection: document.getElementById('resultsSection'),
                    tomtomResults: document.getElementById('tomtomResults'),
                    exportResults: document.getElementById('exportResults'),
                    // Prediction plots elements
                    visualizationGrid: document.querySelector('.visualization-grid')
                };
            }
            
            setupEventListeners() {
                this.elements.fileInput.addEventListener('change', (e) => this.handleFileLoad(e));
                this.elements.stepSlider.addEventListener('input', (e) => this.setStep(parseInt(e.target.value)));
                this.elements.playBtn.addEventListener('click', () => this.togglePlay());
                this.elements.prevBtn.addEventListener('click', () => this.previousStep());
                this.elements.nextBtn.addEventListener('click', () => this.nextStep());
                this.elements.speedSlider.addEventListener('input', () => this.updatePlaySpeed());
                
                document.querySelectorAll('.toggle-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        if (e.target.dataset.mode) {
                            this.setMatrixMode(e.target.dataset.mode);
                        } else if (e.target.dataset.type) {
                            this.setMatrixType(e.target.dataset.type);
                        }
                    });
                });
                
                // Theme toggle
                this.elements.themeToggle.addEventListener('click', () => this.toggleTheme());
                
                // Keyboard navigation
                document.addEventListener('keydown', (e) => this.handleKeydown(e));
                
                // Window resize
                window.addEventListener('resize', () => this.handleResize());
                
                // Global mouse events for selection
                document.addEventListener('mouseup', () => {
                    if (this.isSelecting) {
                        this.isSelecting = false;
                        this.finalizeSelection();
                    }
                });
                
                // TOMTOM event listeners
                this.setupTomtomEventListeners();
            }
            
            handleKeydown(event) {
                if (!this.data) return; // No data loaded
                
                // Don't handle keys when typing in input fields
                if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') return;
                
                switch(event.key) {
                    case 'ArrowUp':
                        event.preventDefault();
                        if (this.currentSample > 0) {
                            this.selectSample(this.currentSample - 1);
                        }
                        break;
                        
                    case 'ArrowDown':
                        event.preventDefault();
                        if (this.currentSample < this.data.metadata.num_samples - 1) {
                            this.selectSample(this.currentSample + 1);
                        }
                        break;
                        
                    case 'ArrowLeft':
                        event.preventDefault();
                        this.previousStep();
                        break;
                        
                    case 'ArrowRight':
                        event.preventDefault();
                        this.nextStep();
                        break;
                        
                    case ' ': // Spacebar
                        event.preventDefault();
                        this.togglePlay();
                        break;
                }
            }
            
            setupViewportSizing() {
                this.updateViewportSizes();
            }
            
            handleResize() {
                // Debounce resize events to prevent excessive recalculation
                clearTimeout(this.resizeTimeout);
                this.resizeTimeout = setTimeout(() => {
                    this.handleLayoutChange();
                }, 150);
            }
            
            handleLayoutChange() {
                // Update viewport-based sizing
                this.updateViewportSizes();
                
                // Refresh charts to fit new size
                if (this.charts) {
                    Object.values(this.charts).forEach(chart => {
                        if (chart.resize) {
                            chart.resize();
                        }
                    });
                }
                
                // Refresh visualizations to fit new container width
                this.refreshVisualizationSizes();
            }
            
            refreshVisualizationSizes() {
                if (!this.data) return;
                
                // Get current step data
                const stepData = this.data.steps[this.currentStep];
                const sampleData = {
                    sequence: stepData.sequences[this.currentSample],
                    scoreMatrix: stepData.score_matrices[this.currentSample],
                    probMatrix: stepData.prob_matrices ? stepData.prob_matrices[this.currentSample] : null,
                    oracleMse: stepData.oracle_mses[this.currentSample]
                };
                
                // Force refresh of matrix/logo visualizations
                this.updateMatrix(sampleData);
                
                // Force refresh sequence display
                this.updateSequenceDisplay(sampleData.sequence);
                if (this.data.metadata.original_samples) {
                    this.updateOriginalSequence();
                }
            }
            
            updateViewportSizes() {
                const vh = window.innerHeight;
                const vw = window.innerWidth;
                
                // Calculate dynamic heights based on viewport
                const headerHeight = 60;
                const controlsHeight = 80;
                const sidebarInfoHeight = 150;
                const padding = 40;
                
                const mainContentHeight = vh - headerHeight - controlsHeight - padding;
                const sidebarContentHeight = vh - sidebarInfoHeight - padding;
                
                // Dynamic chart height based on available space
                let chartHeight = 160;
                if (vh < 800) chartHeight = 120;
                else if (vh < 1000) chartHeight = 140;
                else if (vh > 1200) chartHeight = 180;
                
                // Set CSS custom properties
                document.documentElement.style.setProperty('--main-content-height', `${mainContentHeight}px`);
                document.documentElement.style.setProperty('--sidebar-content-height', `${sidebarContentHeight}px`);
                document.documentElement.style.setProperty('--chart-height', `${chartHeight}px`);
                
                // Trigger a reflow to ensure styles are applied
                document.body.offsetHeight;
            }
            
            initializeTheme() {
                // Check for saved theme first, then system preference, then default to dark
                const savedTheme = localStorage.getItem('visualizer-theme');
                let theme = savedTheme;
                
                if (!savedTheme) {
                    // Check system preference
                    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches) {
                        theme = 'light';
                    } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                        theme = 'dark';
                    } else {
                        theme = 'dark'; // Default fallback
                    }
                }
                
                this.setTheme(theme);
                
                // Listen for system theme changes
                if (window.matchMedia) {
                    window.matchMedia('(prefers-color-scheme: light)').addEventListener('change', (e) => {
                        // Only auto-switch if user hasn't manually set a preference
                        if (!localStorage.getItem('visualizer-theme')) {
                            this.setTheme(e.matches ? 'light' : 'dark');
                        }
                    });
                }
            }
            
            toggleTheme() {
                const newTheme = this.theme === 'dark' ? 'light' : 'dark';
                this.setTheme(newTheme);
            }
            
            setTheme(theme) {
                this.theme = theme;
                document.documentElement.setAttribute('data-theme', theme);
                
                // Update theme icon
                this.elements.themeIcon.textContent = theme === 'dark' ? '☀️' : '🌙';
                
                // Save to localStorage
                localStorage.setItem('visualizer-theme', theme);
                
                // Update chart themes if they exist
                this.updateChartThemes();
            }
            
            updateChartThemes() {
                if (!this.charts || Object.keys(this.charts).length === 0) return;
                
                const chartColors = {
                    dark: {
                        gridColor: '#333',
                        textColor: '#888'
                    },
                    light: {
                        gridColor: '#dee2e6',
                        textColor: '#6c757d'
                    }
                };
                
                const colors = chartColors[this.theme];
                
                // Update main charts (excluding predictions object)
                Object.entries(this.charts).forEach(([key, chart]) => {
                    if (key === 'predictions' || !chart.options?.scales) return;
                    
                    if (chart.options.scales.x?.grid) {
                        chart.options.scales.x.grid.color = colors.gridColor;
                    }
                    if (chart.options.scales.x?.ticks) {
                        chart.options.scales.x.ticks.color = colors.textColor;
                    }
                    if (chart.options.scales.y?.grid) {
                        chart.options.scales.y.grid.color = colors.gridColor;
                    }
                    if (chart.options.scales.y?.ticks) {
                        chart.options.scales.y.ticks.color = colors.textColor;
                    }
                    chart.update('none');
                });
                
                // Update prediction charts
                if (this.charts.predictions) {
                    Object.values(this.charts.predictions).forEach(chart => {
                        if (chart.options?.scales) {
                            if (chart.options.scales.x?.grid) {
                                chart.options.scales.x.grid.color = colors.gridColor;
                            }
                            if (chart.options.scales.x?.ticks) {
                                chart.options.scales.x.ticks.color = colors.textColor;
                            }
                            if (chart.options.scales.x?.title) {
                                chart.options.scales.x.title.color = colors.textColor;
                            }
                            if (chart.options.scales.y?.grid) {
                                chart.options.scales.y.grid.color = colors.gridColor;
                            }
                            if (chart.options.scales.y?.ticks) {
                                chart.options.scales.y.ticks.color = colors.textColor;
                            }
                            if (chart.options.scales.y?.title) {
                                chart.options.scales.y.title.color = colors.textColor;
                            }
                            if (chart.options.plugins?.legend?.labels) {
                                chart.options.plugins.legend.labels.color = colors.textColor;
                            }
                            chart.update('none');
                        }
                    });
                }
            }
            
            // =====================================================
            // TOMTOM FUNCTIONALITY
            // =====================================================
            
            setupTomtomEventListeners() {
                // Panel toggle
                this.elements.tomtomToggle.addEventListener('click', () => this.toggleTomtomPanel());
                
                // Selection controls
                this.elements.enableSelection.addEventListener('click', () => this.toggleSelectionMode());
                this.elements.clearSelection.addEventListener('click', () => this.clearSelection());
                this.elements.selectAll.addEventListener('click', () => this.selectAllPositions());
                
                // Database upload
                this.elements.databaseFile.addEventListener('change', (e) => this.handleDatabaseUpload(e));
                this.setupDragAndDrop();
                
                // Parameter controls
                this.elements.pvalueThreshold.addEventListener('input', (e) => {
                    const value = Math.pow(10, parseFloat(e.target.value));
                    this.elements.pvalueValue.textContent = value.toExponential(1);
                });
                
                this.elements.maxResults.addEventListener('input', () => this.updateRunButtonState());
                this.elements.includeRC.addEventListener('change', () => this.updateRunButtonState());
                
                // TOMTOM execution
                this.elements.runTomtom.addEventListener('click', () => this.runTomtomAnalysis());
                
                // Results export
                this.elements.exportResults.addEventListener('click', () => this.exportTomtomResults());
                
                // Setup hover trigger for collapsed panel
                this.setupHoverTrigger();
            }
            
            toggleTomtomPanel() {
                const container = document.querySelector('.container');
                const panel = this.elements.tomtomPanel;
                const icon = this.elements.tomtomToggleIcon;
                
                const isCollapsed = panel.classList.contains('collapsed');
                
                if (isCollapsed) {
                    // Show panel
                    container.classList.remove('collapsed-tomtom');
                    panel.classList.remove('collapsed');
                    panel.classList.remove('hover-peek');
                    icon.textContent = '◀';
                } else {
                    // Hide panel
                    container.classList.add('collapsed-tomtom');
                    panel.classList.add('collapsed');
                    icon.textContent = '▶';
                }
                
                // Trigger resize after layout change to update content
                setTimeout(() => {
                    this.handleLayoutChange();
                }, 300); // Wait for CSS transition to complete
            }
            
            setupHoverTrigger() {
                // Create hover trigger area
                const hoverTrigger = document.createElement('div');
                hoverTrigger.id = 'tomtom-hover-trigger';
                hoverTrigger.style.cssText = `
                    position: fixed;
                    top: 0;
                    right: 0;
                    width: 20px;
                    height: 100vh;
                    background: transparent;
                    z-index: 1000;
                    display: none;
                    pointer-events: auto;
                `;
                
                document.body.appendChild(hoverTrigger);
                
                // Show/hide trigger based on panel state
                const updateTriggerVisibility = () => {
                    const container = document.querySelector('.container');
                    const isCollapsed = container.classList.contains('collapsed-tomtom');
                    hoverTrigger.style.display = isCollapsed ? 'block' : 'none';
                };
                
                // Initial state
                updateTriggerVisibility();
                
                // Update on panel toggle
                const observer = new MutationObserver(updateTriggerVisibility);
                observer.observe(document.querySelector('.container'), {
                    attributes: true,
                    attributeFilter: ['class']
                });
                
                // Hover events
                hoverTrigger.addEventListener('mouseenter', () => {
                    const panel = this.elements.tomtomPanel;
                    const container = document.querySelector('.container');
                    if (container.classList.contains('collapsed-tomtom')) {
                        panel.classList.add('hover-peek');
                        // Add tab content
                        panel.innerHTML = '<div class="hover-tab-content">TOMTOM</div>';
                        
                        // Add click handler to expand permanently
                        panel.onclick = (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            this.expandTomtomPanel();
                        };
                    }
                });
                
                hoverTrigger.addEventListener('mouseleave', () => {
                    // Small delay to allow moving to panel
                    setTimeout(() => {
                        if (!this.elements.tomtomPanel.matches(':hover')) {
                            this.hideHoverTab();
                        }
                    }, 100);
                });
                
                // Panel hover to keep it visible
                this.elements.tomtomPanel.addEventListener('mouseenter', () => {
                    const container = document.querySelector('.container');
                    if (container.classList.contains('collapsed-tomtom')) {
                        this.elements.tomtomPanel.classList.add('hover-peek');
                    }
                });
                
                // Mouse leave to hide panel
                this.elements.tomtomPanel.addEventListener('mouseleave', () => {
                    const container = document.querySelector('.container');
                    if (container.classList.contains('collapsed-tomtom')) {
                        this.hideHoverTab();
                    }
                });
            }
            
            expandTomtomPanel() {
                const container = document.querySelector('.container');
                const panel = this.elements.tomtomPanel;
                const icon = this.elements.tomtomToggleIcon;
                
                // Restore original panel content
                this.restorePanelContent();
                
                // Show panel permanently
                container.classList.remove('collapsed-tomtom');
                panel.classList.remove('collapsed');
                panel.classList.remove('hover-peek');
                panel.onclick = null; // Remove click handler
                icon.textContent = '◀';
            }
            
            hideHoverTab() {
                const panel = this.elements.tomtomPanel;
                const container = document.querySelector('.container');
                
                if (container.classList.contains('collapsed-tomtom')) {
                    panel.classList.remove('hover-peek');
                    panel.onclick = null; // Remove click handler
                }
            }
            
            restorePanelContent() {
                // Restore the original TOMTOM panel HTML content
                const originalContent = `
                    <div class="tomtom-header">
                        <h3 class="tomtom-title">TOMTOM Analysis</h3>
                        <button class="tomtom-toggle" id="tomtomToggle" title="Toggle TOMTOM Panel">
                            <span id="tomtomToggleIcon">▶</span>
                        </button>
                    </div>
                    
                    <div class="tomtom-content">
                        <!-- Selection Section -->
                        <div class="tomtom-section">
                            <div class="tomtom-section-title">Matrix Selection</div>
                            
                            <div class="selection-info" id="selectionInfo">
                                <div id="selectionStatus">Click and drag on the matrix to select a region</div>
                                <div id="selectionDetails" style="margin-top: 5px; display: none;">
                                    Selection: Position <span id="selectionStart">-</span> to <span id="selectionEnd">-</span> 
                                    (<span id="selectionLength">0</span> positions)
                                </div>
                            </div>
                            
                            <div class="selection-controls">
                                <button class="selection-btn" id="enableSelection">Enable Selection</button>
                                <button class="selection-btn" id="clearSelection">Clear</button>
                                <button class="selection-btn" id="selectAll">Select All</button>
                            </div>
                        </div>
                        
                        <!-- Database Upload Section -->
                        <div class="tomtom-section">
                            <div class="tomtom-section-title">Motif Database</div>
                            
                            <div class="upload-area" id="databaseUpload" onclick="document.getElementById('databaseFile').click()">
                                <div class="upload-icon">📁</div>
                                <div class="upload-text">
                                    Click to upload MEME database file
                                    <br><small>(.meme, .txt formats)</small>
                                </div>
                                <div class="file-name" id="databaseFileName"></div>
                            </div>
                            <input type="file" id="databaseFile" accept=".meme,.txt" style="display: none;">
                        </div>
                        
                        <!-- Parameters Section -->
                        <div class="tomtom-section">
                            <div class="tomtom-section-title">Parameters</div>
                            
                            <div class="param-group">
                                <label class="param-label">P-value Threshold</label>
                                <div class="param-slider">
                                    <input type="range" class="param-range" id="pvalueThreshold" 
                                           min="-5" max="1" step="0.1" value="-3">
                                    <span class="param-value" id="pvalueValue">1.0e-3</span>
                                </div>
                            </div>
                            
                            <div class="param-group">
                                <label class="param-label">Max Results</label>
                                <input type="number" class="param-input" id="maxResults" value="10" min="1" max="100">
                            </div>
                            
                            <div class="param-group">
                                <label class="param-label">
                                    <input type="checkbox" id="includeRC" checked> Include reverse complement
                                </label>
                            </div>
                            
                            <button class="run-tomtom-btn" id="runTomtom" disabled>Run TOMTOM Analysis</button>
                        </div>
                        
                        <!-- Results Section -->
                        <div class="tomtom-section" id="resultsSection" style="display: none;">
                            <div class="tomtom-section-title">Results</div>
                            
                            <div class="tomtom-results" id="tomtomResults">
                                <!-- Results will be populated here -->
                            </div>
                            
                            <button class="selection-btn" id="exportResults" style="margin-top: 10px; width: 100%;">
                                Export Results
                            </button>
                        </div>
                    </div>
                `;
                
                this.elements.tomtomPanel.innerHTML = originalContent;
                
                // Re-initialize the element references and event listeners
                this.initializeTomtomElements();
            }
            
            initializeTomtomElements() {
                // Re-initialize element references after content restoration
                this.elements.tomtomToggle = document.getElementById('tomtomToggle');
                this.elements.tomtomToggleIcon = document.getElementById('tomtomToggleIcon');
                this.elements.selectionInfo = document.getElementById('selectionInfo');
                this.elements.selectionStatus = document.getElementById('selectionStatus');
                this.elements.selectionDetails = document.getElementById('selectionDetails');
                this.elements.selectionStart = document.getElementById('selectionStart');
                this.elements.selectionEnd = document.getElementById('selectionEnd');
                this.elements.selectionLength = document.getElementById('selectionLength');
                this.elements.enableSelection = document.getElementById('enableSelection');
                this.elements.clearSelection = document.getElementById('clearSelection');
                this.elements.selectAll = document.getElementById('selectAll');
                this.elements.databaseUpload = document.getElementById('databaseUpload');
                this.elements.databaseFile = document.getElementById('databaseFile');
                this.elements.databaseFileName = document.getElementById('databaseFileName');
                this.elements.pvalueThreshold = document.getElementById('pvalueThreshold');
                this.elements.pvalueValue = document.getElementById('pvalueValue');
                this.elements.maxResults = document.getElementById('maxResults');
                this.elements.includeRC = document.getElementById('includeRC');
                this.elements.runTomtom = document.getElementById('runTomtom');
                this.elements.resultsSection = document.getElementById('resultsSection');
                this.elements.tomtomResults = document.getElementById('tomtomResults');
                this.elements.exportResults = document.getElementById('exportResults');
                
                // Re-setup event listeners for TOMTOM functionality
                this.setupTomtomEventListeners();
            }
            
            toggleSelectionMode() {
                this.selectionMode = !this.selectionMode;
                const btn = this.elements.enableSelection;
                
                if (this.selectionMode) {
                    btn.textContent = 'Disable Selection';
                    btn.classList.add('active');
                    document.body.classList.add('selection-mode');
                    this.elements.selectionStatus.textContent = 'Selection mode enabled - click and drag on matrix';
                } else {
                    btn.textContent = 'Enable Selection';
                    btn.classList.remove('active');
                    document.body.classList.remove('selection-mode');
                    this.elements.selectionStatus.textContent = 'Click and drag on the matrix to select a region';
                    this.clearSelection();
                }
            }
            
            clearSelection() {
                this.selectedRange = null;
                this.selectionStart = null;
                this.selectionEnd = null;
                this.elements.selectionDetails.style.display = 'none';
                
                // Clear visual highlights
                this.clearSelectionHighlights();
                
                // Refresh matrix display to remove SVG selection overlays
                if (this.data && this.data.steps && this.data.steps[this.currentStep]) {
                    const stepData = this.data.steps[this.currentStep];
                    const sampleData = {
                        sequence: stepData.sequences[this.currentSample],
                        scoreMatrix: stepData.score_matrices[this.currentSample],
                        probMatrix: stepData.prob_matrices ? stepData.prob_matrices[this.currentSample] : null,
                        oracleMse: stepData.oracle_mses[this.currentSample]
                    };
                    this.updateMatrix(sampleData);
                }
                
                this.updateRunButtonState();
            }
            
            selectAllPositions() {
                if (!this.data) return;
                
                const stepData = this.data.steps[this.currentStep];
                const matrix = stepData.score_matrices[this.currentSample];
                
                this.selectedRange = {
                    start: 0,
                    end: matrix.length - 1
                };
                
                this.updateSelectionDisplay();
                this.highlightSelectedRange();
                this.updateRunButtonState();
            }
            
            updateSelectionDisplay() {
                if (this.selectedRange) {
                    this.elements.selectionStart.textContent = this.selectedRange.start + 1;
                    this.elements.selectionEnd.textContent = this.selectedRange.end + 1;
                    this.elements.selectionLength.textContent = this.selectedRange.end - this.selectedRange.start + 1;
                    this.elements.selectionDetails.style.display = 'block';
                    this.elements.selectionStatus.textContent = 'Region selected';
                } else {
                    this.elements.selectionDetails.style.display = 'none';
                }
            }
            
            finalizeSelection() {
                if (this.selectionStart !== null && this.selectionEnd !== null) {
                    const start = Math.min(this.selectionStart, this.selectionEnd);
                    const end = Math.max(this.selectionStart, this.selectionEnd);
                    this.selectedRange = { start, end };
                    
                    // Remove active selection overlays
                    document.querySelectorAll('.selection-overlay-active').forEach(el => el.remove());
                    
                    this.updateSelectionDisplay();
                    
                    // Refresh matrix display to show permanent selection highlights
                    if (this.data && this.data.steps && this.data.steps[this.currentStep]) {
                        const stepData = this.data.steps[this.currentStep];
                        const sampleData = {
                            sequence: stepData.sequences[this.currentSample],
                            scoreMatrix: stepData.score_matrices[this.currentSample],
                            probMatrix: stepData.prob_matrices ? stepData.prob_matrices[this.currentSample] : null,
                            oracleMse: stepData.oracle_mses[this.currentSample]
                        };
                        this.updateMatrix(sampleData);
                    }
                    
                    this.updateRunButtonState();
                }
                
                // Reset selection state
                this.selectionStart = null;
                this.selectionEnd = null;
            }
            
            highlightSelectedRange() {
                // Selection highlighting is now handled directly in the SVG rendering
                // This method is kept for compatibility but the actual highlighting
                // happens in updateHeatmapInContainer through the SVG overlay
                return;
            }
            
            clearSelectionHighlights() {
                // Remove any remaining DOM-based selection overlays
                document.querySelectorAll('.matrix-selection-overlay').forEach(el => el.remove());
                document.querySelectorAll('.selection-overlay-active').forEach(el => el.remove());
                
                // Remove cell highlight classes (though we now use SVG-based highlighting)
                document.querySelectorAll('.matrix-cell-selected').forEach(el => {
                    el.classList.remove('matrix-cell-selected');
                });
            }
            
            startSelection(posIndex, container) {
                this.isSelecting = true;
                this.selectionStart = posIndex;
                this.selectionEnd = posIndex;
                this.createSelectionOverlay(container);
                this.updateSelectionOverlay(container);
                this.updateSelectionDisplay();
            }
            
            updateSelectionEnd(posIndex, container) {
                this.selectionEnd = posIndex;
                this.updateSelectionOverlay(container);
                this.updateSelectionDisplay();
            }
            
            createSelectionOverlay(container) {
                // Remove existing overlay first
                const existingOverlay = container.querySelector('.selection-overlay-active');
                if (existingOverlay) {
                    existingOverlay.remove();
                }
                
                // Create new overlay
                const overlay = document.createElement('div');
                overlay.className = 'selection-overlay-active';
                overlay.style.position = 'absolute';
                overlay.style.background = 'rgba(251, 146, 60, 0.2)';
                overlay.style.border = '2px dotted #fb923c';
                overlay.style.borderRadius = '2px';
                overlay.style.pointerEvents = 'none';
                overlay.style.zIndex = '10';
                
                container.style.position = 'relative';
                container.appendChild(overlay);
            }
            
            updateSelectionOverlay(container) {
                const overlay = container.querySelector('.selection-overlay-active');
                if (!overlay || this.selectionStart === null || this.selectionEnd === null) return;
                
                const cellSize = 12;
                const start = Math.min(this.selectionStart, this.selectionEnd);
                const end = Math.max(this.selectionStart, this.selectionEnd);
                
                overlay.style.left = (30 + start * cellSize) + 'px';
                overlay.style.top = '15px';
                overlay.style.width = ((end - start + 1) * cellSize) + 'px';
                overlay.style.height = (4 * cellSize) + 'px';
            }
            
            startLogoSelection(posIndex, container, leftOffset, positionWidth) {
                this.isSelecting = true;
                this.selectionStart = posIndex;
                this.selectionEnd = posIndex;
                this.createLogoSelectionOverlay(container, leftOffset, positionWidth);
                this.updateLogoSelectionOverlay(container, leftOffset, positionWidth);
                this.updateSelectionDisplay();
            }
            
            updateLogoSelectionEnd(posIndex, container, leftOffset, positionWidth) {
                this.selectionEnd = posIndex;
                this.updateLogoSelectionOverlay(container, leftOffset, positionWidth);
                this.updateSelectionDisplay();
            }
            
            createLogoSelectionOverlay(container, leftOffset, positionWidth) {
                // Remove existing overlay first
                const existingOverlay = container.querySelector('.selection-overlay-active');
                if (existingOverlay) {
                    existingOverlay.remove();
                }
                
                // Create new overlay
                const overlay = document.createElement('div');
                overlay.className = 'selection-overlay-active';
                overlay.style.position = 'absolute';
                overlay.style.background = 'rgba(251, 146, 60, 0.2)';
                overlay.style.border = '2px dotted #fb923c';
                overlay.style.borderRadius = '2px';
                overlay.style.pointerEvents = 'none';
                overlay.style.zIndex = '10';
                
                container.appendChild(overlay);
            }
            
            updateLogoSelectionOverlay(container, leftOffset, positionWidth) {
                const overlay = container.querySelector('.selection-overlay-active');
                if (!overlay || this.selectionStart === null || this.selectionEnd === null) return;
                
                const start = Math.min(this.selectionStart, this.selectionEnd);
                const end = Math.max(this.selectionStart, this.selectionEnd);
                
                overlay.style.left = (leftOffset + start * positionWidth) + 'px';
                overlay.style.top = '20px';
                overlay.style.width = ((end - start + 1) * positionWidth) + 'px';
                overlay.style.height = 'calc(100% - 40px)';
            }
            
            setupDragAndDrop() {
                const uploadArea = this.elements.databaseUpload;
                
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                    });
                });
                
                ['dragenter', 'dragover'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, () => {
                        uploadArea.classList.add('dragover');
                    });
                });
                
                ['dragleave', 'drop'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, () => {
                        uploadArea.classList.remove('dragover');
                    });
                });
                
                uploadArea.addEventListener('drop', (e) => {
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.elements.databaseFile.files = files;
                        this.handleDatabaseUpload({ target: { files } });
                    }
                });
            }
            
            async handleDatabaseUpload(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                try {
                    const text = await file.text();
                    
                    // Validate MEME format
                    if (!this.validateMemeFormat(text)) {
                        throw new Error('Invalid MEME format. Please upload a valid MEME file.');
                    }
                    
                    this.uploadedDatabase = text;
                    this.elements.databaseFileName.textContent = file.name;
                    this.elements.databaseUpload.classList.add('has-file');
                    this.updateRunButtonState();
                    
                } catch (error) {
                    console.error('Database upload error:', error);
                    alert('Error uploading database: ' + error.message);
                }
            }
            
            validateMemeFormat(content) {
                if (!content || content.trim().length === 0) return false;
                
                const lines = content.split('\n').map(line => line.trim());
                const hasVersion = lines.some(line => line.startsWith('MEME version'));
                const hasAlphabet = lines.some(line => line.startsWith('ALPHABET='));
                const hasMotif = lines.some(line => line.startsWith('MOTIF '));
                
                return hasVersion && hasAlphabet && hasMotif;
            }
            
            updateRunButtonState() {
                const hasSelection = this.selectedRange !== null;
                const hasDatabase = this.uploadedDatabase !== null;
                const hasParams = this.elements.maxResults.value > 0;
                
                this.elements.runTomtom.disabled = !(hasSelection && hasDatabase && hasParams);
            }
            
            async runTomtomAnalysis() {
                if (!this.selectedRange || !this.uploadedDatabase) {
                    alert('Please select a matrix region and upload a motif database.');
                    return;
                }
                
                try {
                    this.elements.runTomtom.disabled = true;
                    this.elements.runTomtom.textContent = 'Running...';
                    
                    // Extract selected motif
                    const selectedMotif = this.extractSelectedMotif();
                    
                    // Run TOMTOM using memesuite-lite.js
                    const results = await this.performTomtomComparison(selectedMotif);
                    
                    // Display results
                    this.displayTomtomResults(results);
                    
                } catch (error) {
                    console.error('TOMTOM analysis error:', error);
                    alert('TOMTOM analysis failed: ' + error.message);
                } finally {
                    this.elements.runTomtom.disabled = false;
                    this.elements.runTomtom.textContent = 'Run TOMTOM Analysis';
                }
            }
            
            extractSelectedMotif() {
                const stepData = this.data.steps[this.currentStep];
                const matrix = this.matrixType === 'prob' && stepData.prob_matrices ? 
                    stepData.prob_matrices[this.currentSample] : 
                    stepData.score_matrices[this.currentSample];
                
                // Extract the selected region
                const selectedMatrix = matrix.slice(this.selectedRange.start, this.selectedRange.end + 1);
                
                // Convert to MEME format
                return this.convertToMemeFormat(selectedMatrix);
            }
            
            convertToMemeFormat(matrix) {
                const motifName = `Selected_Region_${this.selectedRange.start + 1}_${this.selectedRange.end + 1}`;
                const alphabet = 'ACGT';
                const length = matrix.length;
                
                let memeContent = `MEME version 4\n\nALPHABET= ${alphabet}\n\nstrands: + -\n\n`;
                memeContent += `Background letter frequencies\nA 0.25 C 0.25 G 0.25 T 0.25\n\n`;
                memeContent += `MOTIF ${motifName}\nletter-probability matrix: alength= 4 w= ${length} nsites= 20 E= 0\n`;
                
                matrix.forEach(position => {
                    // Normalize to probabilities if needed
                    const total = position.reduce((a, b) => a + Math.max(0, b), 0);
                    const normalized = total > 0 ? 
                        position.map(val => Math.max(0, val) / total) : 
                        [0.25, 0.25, 0.25, 0.25];
                    
                    memeContent += normalized.map(val => val.toFixed(6)).join(' ') + '\n';
                });
                
                return memeContent;
            }
            
            async performTomtomComparison(queryMotif) {
                try {
                    if (!this.uploadedDatabase) {
                        throw new Error('No database uploaded');
                    }
                    
                    // Initialize MemeSuite-Lite
                    const memeSuite = new MemeSuiteLite();
                    
                    // Get threshold and max results from UI
                    const threshold = Math.pow(10, parseFloat(this.elements.pvalueThreshold.value)) || 0.001;
                    const maxResults = parseInt(this.elements.maxResults.value) || 10;
                    
                    // Run TOMTOM analysis
                    const results = memeSuite.runTomtom(queryMotif, this.uploadedDatabase, {
                        threshold: threshold,
                        reverseComplement: this.elements.includeRC.checked
                    });
                    
                    // Parse results and convert to our format
                    const queryMotifs = memeSuite.readMeme(queryMotif);
                    const targetMotifs = memeSuite.readMeme(this.uploadedDatabase);
                    const targetNames = Object.keys(targetMotifs);
                    const queryNames = Object.keys(queryMotifs);
                    
                    const matches = [];
                    
                    // Process results (pValues is a 2D array: queries x targets)
                    if (results.pValues && results.pValues.length > 0 && queryNames.length > 0) {
                        const queryIdx = 0; // We're comparing a single query motif
                        
                        // Process ALL motifs in the database
                        for (let targetIdx = 0; targetIdx < targetNames.length; targetIdx++) {
                            const pValue = results.pValues[queryIdx][targetIdx];
                            const score = results.scores[queryIdx][targetIdx];
                            const offset = results.offsets[queryIdx][targetIdx];
                            const overlap = results.overlaps[queryIdx][targetIdx];
                            const strand = results.strands[queryIdx][targetIdx] === 0 ? '+' : '-';
                            
                            if (pValue <= threshold) {
                                matches.push({
                                    name: targetNames[targetIdx],
                                    pvalue: pValue,
                                    score: score,
                                    offset: offset,
                                    overlap: overlap,
                                    strand: strand,
                                    alignment: this.generateAlignment(queryMotifs[queryNames[0]], targetMotifs[targetNames[targetIdx]], offset)
                                });
                            }
                        }
                    }
                    
                    // Sort by p-value (ascending) and return top results
                    matches.sort((a, b) => a.pvalue - b.pvalue);
                    
                    return {
                        matches: matches.slice(0, maxResults)
                    };
                    
                } catch (error) {
                    console.error('TOMTOM analysis failed:', error);
                    this.elements.selectionStatus.textContent = `Error: ${error.message}`;
                    throw error;
                }
            }
            
            generateAlignment(queryPwm, targetPwm, offset) {
                // Convert PWM to consensus sequence for alignment visualization
                const memeSuite = new MemeSuiteLite();
                const alphabet = ['A', 'C', 'G', 'T'];
                
                try {
                    const querySeq = memeSuite.characters(queryPwm, alphabet, true);
                    const targetSeq = memeSuite.characters(targetPwm, alphabet, true);
                    
                    // Create alignment string with offset
                    let alignment = '';
                    const queryLen = querySeq.length;
                    const targetLen = targetSeq.length;
                    
                    for (let i = 0; i < Math.max(queryLen, targetLen + Math.abs(offset)); i++) {
                        const qIdx = i;
                        const tIdx = i - offset;
                        
                        const qChar = (qIdx >= 0 && qIdx < queryLen) ? querySeq[qIdx] : '-';
                        const tChar = (tIdx >= 0 && tIdx < targetLen) ? targetSeq[tIdx] : '-';
                        
                        alignment += qChar === tChar ? qChar : (qChar + '/' + tChar);
                    }
                    
                    return alignment.substring(0, 20) + (alignment.length > 20 ? '...' : '');
                    
                } catch (error) {
                    console.warn('Alignment generation failed:', error);
                    return 'N/A';
                }
            }
            
            displayTomtomResults(results) {
                this.tomtomResults = results;
                this.elements.resultsSection.style.display = 'block';
                
                if (results.matches && results.matches.length > 0) {
                    // Create enhanced results display
                    this.elements.tomtomResults.innerHTML = `
                        <div class="results-header">
                            <h4>TOMTOM Results (${results.matches.length} matches found)</h4>
                            <button class="export-btn" onclick="app.exportTomtomResults()">Export CSV</button>
                        </div>
                        <div class="results-table-container">
                            <table class="results-table">
                                <thead>
                                    <tr>
                                        <th>Rank</th>
                                        <th>Target Motif</th>
                                        <th>P-value</th>
                                        <th>Score</th>
                                        <th>Offset</th>
                                        <th>Overlap</th>
                                        <th>Strand</th>
                                        <th>Alignment</th>
                                        <th>Actions</th>
                                    </tr>
                                </thead>
                                <tbody id="results-tbody">
                                </tbody>
                            </table>
                        </div>
                        <div id="motif-detail-panel" class="motif-detail-panel" style="display: none;">
                            <div class="detail-header">
                                <h5 id="detail-motif-name">Motif Details</h5>
                                <button onclick="document.getElementById('motif-detail-panel').style.display='none'">×</button>
                            </div>
                            <div class="detail-content">
                                <div class="logo-comparison">
                                    <div class="logo-container">
                                        <h6>Query Motif</h6>
                                        <div id="query-logo" class="motif-logo"></div>
                                    </div>
                                    <div class="logo-container">
                                        <h6>Target Motif</h6>
                                        <div id="target-logo" class="motif-logo"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    // Populate table rows
                    const tbody = document.getElementById('results-tbody');
                    results.matches.forEach((match, index) => {
                        const row = document.createElement('tr');
                        row.className = 'result-row';
                        row.innerHTML = `
                            <td>${index + 1}</td>
                            <td class="motif-name">${match.name}</td>
                            <td class="p-value">${match.pvalue.toExponential(2)}</td>
                            <td class="score">${match.score.toFixed(3)}</td>
                            <td class="offset">${match.offset}</td>
                            <td class="overlap">${match.overlap}</td>
                            <td class="strand ${match.strand === '+' ? 'positive' : 'negative'}">${match.strand}</td>
                            <td class="alignment">${match.alignment}</td>
                            <td class="actions">
                                <button class="detail-btn" onclick="app.showMotifComparison('${match.name}', ${index})">
                                    View Details
                                </button>
                            </td>
                        `;
                        tbody.appendChild(row);
                    });
                } else {
                    this.elements.tomtomResults.innerHTML = `
                        <div class="no-results">
                            <div class="no-results-icon">🔍</div>
                            <h4>No significant matches found</h4>
                            <p>Try adjusting the p-value threshold or uploading a different database.</p>
                        </div>
                    `;
                }
            }
            
            exportTomtomResults() {
                if (!this.tomtomResults) return;
                
                let csv = 'Motif Name,P-value,Score,Offset,Overlap,Strand,Alignment\n';
                this.tomtomResults.matches.forEach(match => {
                    csv += `${match.name},${match.pvalue},${match.score},${match.offset},${match.overlap},${match.strand},"${match.alignment}"\n`;
                });
                
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `tomtom_results_${new Date().toISOString().slice(0,10)}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            
            async showMotifComparison(targetMotifName, matchIndex) {
                try {
                    if (!this.uploadedDatabase || !this.tomtomResults) return;
                    
                    // Show the detail panel
                    const detailPanel = document.getElementById('motif-detail-panel');
                    const detailMotifName = document.getElementById('detail-motif-name');
                    const queryLogoDiv = document.getElementById('query-logo');
                    const targetLogoDiv = document.getElementById('target-logo');
                    
                    detailMotifName.textContent = `Comparison: Query vs ${targetMotifName}`;
                    
                    // Clear previous logos
                    queryLogoDiv.innerHTML = '';
                    targetLogoDiv.innerHTML = '';
                    
                    // Get the query motif (selected region)
                    const queryMotifMeme = this.extractSelectedMotif();
                    const memeSuite = new MemeSuiteLite();
                    const queryMotifs = memeSuite.readMeme(queryMotifMeme);
                    const queryMotifName = Object.keys(queryMotifs)[0];
                    const queryPwm = queryMotifs[queryMotifName];
                    
                    // Get the target motif
                    const targetMotifs = memeSuite.readMeme(this.uploadedDatabase);
                    const targetPwm = targetMotifs[targetMotifName];
                    
                    if (queryPwm && targetPwm) {
                        // Convert PWMs to LogoJS format and create logos
                        await Promise.all([
                            this.createMotifLogo(queryPwm, queryLogoDiv, 'Query Motif'),
                            this.createMotifLogo(targetPwm, targetLogoDiv, targetMotifName)
                        ]);
                    }
                    
                    // Show the panel
                    detailPanel.style.display = 'block';
                    
                    // Make panel draggable
                    this.makePanelDraggable(detailPanel);
                    
                } catch (error) {
                    console.error('Error showing motif comparison:', error);
                    alert('Error displaying motif comparison: ' + error.message);
                }
            }
            
            async createMotifLogo(pwm, container, title) {
                try {
                    // Convert PWM to the format expected by our logo system
                    const convertedMatrix = this.convertPwmToMatrix(pwm);
                    
                    // Create a div for the logo
                    const logoDiv = document.createElement('div');
                    logoDiv.id = 'motif-logo-' + Date.now();
                    container.appendChild(logoDiv);
                    
                    // Get theme-appropriate colors for DNA bases
                    const themeColors = this.getThemeBasesColors();
                    
                    // Use the same logojs API as in the main application
                    if (typeof logojs !== 'undefined') {
                        // Create custom DNA alphabet with theme colors
                        const customAlphabet = [
                            {regex: 'A', color: themeColors.A, component: logojs.A},
                            {regex: 'C', color: themeColors.C, component: logojs.C}, 
                            {regex: 'G', color: themeColors.G, component: logojs.G},
                            {regex: 'T', color: themeColors.T, component: logojs.T}
                        ];
                        
                        // Calculate optimal logo width based on motif length
                        const logoWidth = Math.min(convertedMatrix.length * 18 + 60, 300);
                        const logoConfig = {
                            ppm: convertedMatrix,
                            alphabet: customAlphabet,
                            width: logoWidth,
                            height: 120,
                            mode: 'INFORMATION_CONTENT',
                            style: {
                                textColor: this.theme === 'dark' ? '#ffffff' : '#6c757d',
                                axisColor: this.theme === 'dark' ? '#ffffff' : '#6c757d'
                            }
                        };
                        
                        if (logojs.embedLogo) {
                            logojs.embedLogo(logoDiv, logoConfig);
                        } else if (logojs.embedDNALogo) {
                            logojs.embedDNALogo(logoDiv, logoConfig);
                        } else {
                            throw new Error('LogoJS embedding functions not available');
                        }
                    } else {
                        throw new Error('LogoJS not available');
                    }
                } catch (error) {
                    console.warn('Logo creation failed, using text fallback:', error);
                    // Fallback: create a simple text representation
                    const consensus = this.generateConsensusFromPwm(pwm);
                    container.innerHTML = `<div style="font-family: monospace; font-size: 14px; text-align: center; padding: 20px; background: #f5f5f5; border-radius: 4px; border: 1px solid #ddd;">${consensus}</div>`;
                }
            }
            
            convertPwmToMatrix(pwm) {
                // Convert PWM format to our matrix format (positions x bases)
                const matrixLength = pwm[0] ? pwm[0].length : pwm.length;
                const convertedMatrix = [];
                
                for (let pos = 0; pos < matrixLength; pos++) {
                    const position = [
                        pwm[0] ? pwm[0][pos] : pwm[pos][0],  // A
                        pwm[1] ? pwm[1][pos] : pwm[pos][1],  // C
                        pwm[2] ? pwm[2][pos] : pwm[pos][2],  // G
                        pwm[3] ? pwm[3][pos] : pwm[pos][3]   // T
                    ];
                    
                    // Normalize to ensure sum = 1
                    const total = position.reduce((a, b) => a + Math.max(0, b || 0), 0);
                    if (total > 0) {
                        convertedMatrix.push(position.map(val => Math.max(0, val || 0) / total));
                    } else {
                        convertedMatrix.push([0.25, 0.25, 0.25, 0.25]);
                    }
                }
                
                return convertedMatrix;
            }
            
            generateConsensusFromPwm(pwm) {
                const bases = ['A', 'C', 'G', 'T'];
                const matrixLength = pwm[0] ? pwm[0].length : pwm.length;
                let consensus = '';
                
                for (let pos = 0; pos < Math.min(matrixLength, 50); pos++) {
                    const position = [
                        pwm[0] ? pwm[0][pos] : pwm[pos][0],
                        pwm[1] ? pwm[1][pos] : pwm[pos][1],
                        pwm[2] ? pwm[2][pos] : pwm[pos][2],
                        pwm[3] ? pwm[3][pos] : pwm[pos][3]
                    ];
                    
                    // Find the most probable base
                    let maxIdx = 0;
                    let maxVal = position[0] || 0;
                    for (let i = 1; i < position.length; i++) {
                        if ((position[i] || 0) > maxVal) {
                            maxVal = position[i] || 0;
                            maxIdx = i;
                        }
                    }
                    
                    consensus += bases[maxIdx];
                }
                
                return consensus + (matrixLength > 50 ? '...' : '');
            }
            
            makePanelDraggable(panel) {
                let isDragging = false;
                let dragOffset = { x: 0, y: 0 };
                
                // Add drag functionality to the header
                const header = panel.querySelector('.detail-header');
                if (!header) return;
                
                header.style.cursor = 'move';
                
                const startDrag = (e) => {
                    isDragging = true;
                    const rect = panel.getBoundingClientRect();
                    dragOffset.x = e.clientX - rect.left;
                    dragOffset.y = e.clientY - rect.top;
                    
                    document.addEventListener('mousemove', drag);
                    document.addEventListener('mouseup', stopDrag);
                    e.preventDefault();
                };
                
                const drag = (e) => {
                    if (!isDragging) return;
                    
                    const newX = e.clientX - dragOffset.x;
                    const newY = e.clientY - dragOffset.y;
                    
                    // Keep panel within viewport bounds
                    const maxX = window.innerWidth - panel.offsetWidth;
                    const maxY = window.innerHeight - panel.offsetHeight;
                    
                    const boundedX = Math.max(0, Math.min(newX, maxX));
                    const boundedY = Math.max(0, Math.min(newY, maxY));
                    
                    panel.style.left = boundedX + 'px';
                    panel.style.top = boundedY + 'px';
                    panel.style.transform = 'none';
                };
                
                const stopDrag = () => {
                    isDragging = false;
                    document.removeEventListener('mousemove', drag);
                    document.removeEventListener('mouseup', stopDrag);
                };
                
                header.addEventListener('mousedown', startDrag);
            }
            
            convertPwmToLogoFormat(pwm) {
                // Convert our PWM format [4 x length] to LogoJS format
                const length = pwm[0].length;
                const logoData = [];
                
                for (let pos = 0; pos < length; pos++) {
                    const position = {};
                    const bases = ['A', 'C', 'G', 'T'];
                    
                    bases.forEach((base, baseIdx) => {
                        const freq = pwm[baseIdx][pos];
                        if (freq > 0.01) { // Only include significant frequencies
                            position[base] = freq;
                        }
                    });
                    
                    logoData.push(position);
                }
                
                return logoData;
            }
            
            async handleFileLoad(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                this.elements.sampleList.innerHTML = '<div class="loading">Loading file...</div>';
                
                try {
                    const fileExtension = file.name.toLowerCase().split('.').pop();
                    
                    if (fileExtension === 'h5' || fileExtension === 'hdf5') {
                        this.data = await this.loadHDF5File(file);
                    } else if (fileExtension === 'json') {
                        this.data = await this.loadJSONFile(file);
                    } else {
                        throw new Error('Unsupported file format. Please use .h5, .hdf5, or .json files.');
                    }
                    
                    this.initializeVisualization();
                } catch (error) {
                    console.error('Error loading file:', error);
                    alert(`Error loading file: ${error.message}`);
                    this.elements.sampleList.innerHTML = '<div class="loading">Load a data file to begin</div>';
                }
            }
            

            
            async loadHDF5File(file) {
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    
                    // Use h5wasm to parse HDF5 file
                    const h5file = await h5wasm.HDF5File.open(arrayBuffer);
                    
                    // Extract metadata
                    const metadata = {};
                    if (h5file.has('metadata')) {
                        const metadataGroup = h5file.get('metadata');
                        
                        // Get attributes
                        const attrs = metadataGroup.attrs;
                        for (const [key, value] of Object.entries(attrs)) {
                            if (typeof value === 'number') {
                                metadata[key] = value;
                            } else if (Array.isArray(value)) {
                                metadata[key] = Array.from(value);
                            } else {
                                metadata[key] = value;
                            }
                        }
                        
                        // Get original_samples if available
                        if (metadataGroup.has('original_samples')) {
                            const originalSamples = metadataGroup.get('original_samples');
                            metadata.original_samples = Array.from(originalSamples.value);
                        }
                    }
                    
                    // Extract steps data
                    const steps = [];
                    if (h5file.has('steps')) {
                        const stepsGroup = h5file.get('steps');
                        
                        // Get all step keys and sort them
                        const stepKeys = Array.from(stepsGroup.keys()).filter(key => key.startsWith('step_'));
                        stepKeys.sort((a, b) => {
                            const aNum = parseInt(a.replace('step_', ''));
                            const bNum = parseInt(b.replace('step_', ''));
                            return aNum - bNum;
                        });
                        
                        for (const stepKey of stepKeys) {
                            const step = stepsGroup.get(stepKey);
                            const stepData = {
                                step: parseInt(step.attrs.step || stepKey.replace('step_', '')),
                                timestep: parseFloat(step.attrs.timestep || 0),
                                noise_level: parseFloat(step.attrs.noise_level || 0),
                                noise_rate: parseFloat(step.attrs.noise_rate || 0),
                                sequences: Array.from(step.get('sequence').value),
                                score_matrices: Array.from(step.get('score_matrix').value),
                                prob_matrices: step.has('prob_matrix') ? Array.from(step.get('prob_matrix').value) : null,
                                oracle_mses: step.has('oracle_mse') ? Array.from(step.get('oracle_mse').value) : []
                            };
                            steps.push(stepData);
                        }
                    }
                    
                    return {
                        metadata: metadata,
                        steps: steps
                    };
                    
                } catch (error) {
                    console.error('Error parsing HDF5 file:', error);
                    throw new Error(`Failed to parse HDF5 file: ${error.message}`);
                }
            }
            
            // Alternative: Load from JSON format
            async loadJSONFile(file) {
                const text = await file.text();
                const data = JSON.parse(text);
                
                // Validate the data structure matches expected format
                if (!data.metadata || !data.steps) {
                    throw new Error('Invalid data format. Expected structure with metadata and steps.');
                }
                
                return data;
            }
            
            initializeVisualization() {
                this.elements.placeholderContent.classList.add('hidden');
                this.elements.mainContent.classList.remove('hidden');
                
                // Show/hide original sequence section based on data availability
                if (this.data.metadata.original_samples) {
                    this.elements.originalSequenceSection.style.display = 'block';
                    this.updateOriginalSequence();
                } else {
                    this.elements.originalSequenceSection.style.display = 'none';
                }
                
                // Set up prediction plots sections based on data availability
                if (this.data.metadata.ground_truth_labels && 
                    this.data.steps && this.data.steps.length > 0 && 
                    this.data.steps[0].oracle_predictions) {
                    this.setupPredictionPlots();
                } else {
                    // Clear any existing prediction plots
                    this.clearPredictionPlots();
                }
                
                this.updateDatasetInfo();
                this.createSampleList();
                this.setupSlider();
                this.selectSample(0);
                this.updateCharts();
            }
            
            updateDatasetInfo() {
                const meta = this.data.metadata;
                this.elements.datasetInfo.innerHTML = `
                    Dataset: ${meta.dataset}<br>
                    Samples: ${meta.num_samples}<br>
                    Sequence Length: ${meta.sequence_length}<br>
                    Steps: ${meta.total_steps}<br>
                    Architecture: ${meta.architecture}
                `;
            }
            
            createSampleList() {
                this.elements.sampleList.innerHTML = '';
                for (let i = 0; i < this.data.metadata.num_samples; i++) {
                    const item = document.createElement('div');
                    item.className = 'sample-item';
                    
                    // Create sample text with dataset index if available
                    let sampleText = `Sample ${i + 1}`;
                    if (this.data.metadata.dataset_indices && this.data.metadata.dataset_indices[i] !== undefined) {
                        sampleText += ` (Index: ${this.data.metadata.dataset_indices[i]})`;
                    }
                    
                    item.textContent = sampleText;
                    item.addEventListener('click', () => this.selectSample(i));
                    this.elements.sampleList.appendChild(item);
                }
            }
            
            setupSlider() {
                this.elements.stepSlider.max = this.data.metadata.total_steps - 1;
                this.elements.stepSlider.value = 0;
                this.currentStep = 0;
                this.updateStepInfo();
            }
            
            selectSample(sampleIndex) {
                this.currentSample = sampleIndex;
                
                // Clear highlight when switching samples (different sequence)
                this.highlightedPosition = null;
                
                // Update active sample in list
                document.querySelectorAll('.sample-item').forEach((item, index) => {
                    item.classList.toggle('active', index === sampleIndex);
                });
                
                // Update original sequence if available
                if (this.data.metadata.original_samples) {
                    this.updateOriginalSequence();
                }
                
                this.updateVisualization();
                this.updateCharts();
            }
            
            setStep(step) {
                this.currentStep = Math.max(0, Math.min(step, this.data.metadata.total_steps - 1));
                this.elements.stepSlider.value = this.currentStep;
                this.updateStepInfo();
                this.updateVisualization();
                this.updateChartProgress();
            }
            
            updateStepInfo() {
                const stepData = this.data.steps[this.currentStep];
                this.elements.stepInfo.textContent = `Step: ${this.currentStep} / ${this.data.metadata.total_steps - 1}`;
                
                // Add noise level info
                if (stepData) {
                    this.elements.stepInfo.textContent += ` | Noise: ${stepData.noise_level.toFixed(3)}`;
                }
            }
            
            updateVisualization() {
                if (!this.data) return;
                
                const stepData = this.data.steps[this.currentStep];
                const sampleData = {
                    sequence: stepData.sequences[this.currentSample],
                    scoreMatrix: stepData.score_matrices[this.currentSample],
                    probMatrix: stepData.prob_matrices ? stepData.prob_matrices[this.currentSample] : null,
                    oracleMse: stepData.oracle_mses[this.currentSample]
                };
                
                this.updateSequenceDisplay(sampleData.sequence);
                this.updateMatrix(sampleData);
            }
            
            updateSequenceDisplay(sequence) {
                const baseNames = ['A', 'C', 'G', 'T'];
                const baseClasses = ['base-A', 'base-C', 'base-G', 'base-T'];
                
                let html = '';
                sequence.forEach((base, index) => {
                    const isHighlighted = this.highlightedPosition === index;
                    const highlightClass = isHighlighted ? ' nucleotide-highlight' : '';
                    html += `<span class="${baseClasses[base]}${highlightClass}" data-position="${index}">${baseNames[base]}</span>`;
                    // Add space every 10 bases for readability but keep single line
                    if ((index + 1) % 10 === 0) html += ' ';
                });
                
                this.elements.sequenceText.innerHTML = html;
                
                // Update position axis
                this.updatePositionAxis(sequence.length);
                
                // Update stats
                const baseCounts = [0, 0, 0, 0];
                sequence.forEach(base => baseCounts[base]++);
                const total = sequence.length;
                
                this.elements.sequenceStats.innerHTML = 
                    `A:${(baseCounts[0]/total*100).toFixed(1)}% ` +
                    `C:${(baseCounts[1]/total*100).toFixed(1)}% ` +
                    `G:${(baseCounts[2]/total*100).toFixed(1)}% ` +
                    `T:${(baseCounts[3]/total*100).toFixed(1)}%`;
            }
            
            updateOriginalSequence() {
                if (!this.data.metadata.original_samples) return;
                
                const originalSequence = this.data.metadata.original_samples[this.currentSample];
                const baseNames = ['A', 'C', 'G', 'T'];
                const baseClasses = ['base-A', 'base-C', 'base-G', 'base-T'];
                
                let html = '';
                originalSequence.forEach((base, index) => {
                    const isHighlighted = this.highlightedPosition === index;
                    const highlightClass = isHighlighted ? ' nucleotide-highlight' : '';
                    html += `<span class="${baseClasses[base]}${highlightClass}" data-position="${index}">${baseNames[base]}</span>`;
                    // Add space every 10 bases for readability but keep single line
                    if ((index + 1) % 10 === 0) html += ' ';
                });
                
                this.elements.originalSequenceText.innerHTML = html;
                
                // Update position axis
                this.updatePositionAxis(originalSequence.length);
            }
            
            toggleNucleotideHighlight(position) {
                // Toggle highlight: if same position clicked, remove highlight; otherwise, set new position
                if (this.highlightedPosition === position) {
                    this.highlightedPosition = null;
                } else {
                    this.highlightedPosition = position;
                    this.scrollToNucleotide(position);
                }
                
                // Update sequence display to reflect highlight changes
                if (this.data) {
                    const stepData = this.data.steps[this.currentStep];
                    this.updateSequenceDisplay(stepData.sequences[this.currentSample]);
                    
                    // Also update original sequence if available
                    if (this.data.metadata.original_samples) {
                        this.updateOriginalSequence();
                    }
                    
                    // Update matrix to reflect highlight changes
                    const sampleData = {
                        sequence: stepData.sequences[this.currentSample],
                        scoreMatrix: stepData.score_matrices[this.currentSample],
                        probMatrix: stepData.prob_matrices ? stepData.prob_matrices[this.currentSample] : null,
                        oracleMse: stepData.oracle_mses[this.currentSample]
                    };
                    this.updateMatrix(sampleData);
                }
            }
            
            scrollToNucleotide(position) {
                // Small delay to ensure DOM has been updated after sequence refresh
                setTimeout(() => {
                    const sequenceContainer = this.elements.sequenceScrollContainer;
                    if (!sequenceContainer) return;
                    
                    // Find the highlighted nucleotide span
                    const highlightedSpan = sequenceContainer.querySelector(`[data-position="${position}"]`);
                    if (!highlightedSpan) return;
                    
                    // Get the position of the nucleotide relative to the container
                    const containerRect = sequenceContainer.getBoundingClientRect();
                    const spanRect = highlightedSpan.getBoundingClientRect();
                    
                    // Calculate scroll position to center the nucleotide horizontally
                    const containerWidth = sequenceContainer.clientWidth;
                    const currentScrollLeft = sequenceContainer.scrollLeft;
                    const spanLeftRelative = spanRect.left - containerRect.left + currentScrollLeft;
                    const targetScrollLeft = spanLeftRelative - (containerWidth / 2) + (spanRect.width / 2);
                
                    // Smooth scroll to the target position
                    sequenceContainer.scrollTo({
                        left: Math.max(0, targetScrollLeft),
                        behavior: 'smooth'
                    });
                }, 50); // 50ms delay
            }
            
            updateMatrix(sampleData) {
                const matrixSection = document.querySelector('.score-matrix-section');
                
                if (this.matrixType === 'both' && sampleData.probMatrix) {
                    // Show both matrices
                    this.elements.matrixTitle.textContent = 'Score & Probability Matrices';
                    this.elements.singleMatrixContainer.classList.add('hidden');
                    this.elements.dualMatrixContainer.classList.remove('hidden');
                    matrixSection.classList.add('dual-mode');
                    
                    // Add logo-mode class if in logo mode
                    if (this.matrixMode === 'logo') {
                        matrixSection.classList.add('logo-mode');
                    } else {
                        matrixSection.classList.remove('logo-mode');
                    }
                    
                    // Update both matrices
                    this.updateDualMatrices(sampleData);
                } else {
                    // Show single matrix
                    this.elements.singleMatrixContainer.classList.remove('hidden');
                    this.elements.dualMatrixContainer.classList.add('hidden');
                    matrixSection.classList.remove('dual-mode', 'logo-mode');
                    
                    // Remove synchronized scrolling when switching to single mode
                    this.removeSynchronizedScrolling();
                    
                    // Determine which matrix to use
                    let currentMatrix;
                    if (this.matrixType === 'prob' && sampleData.probMatrix) {
                        currentMatrix = sampleData.probMatrix;
                        this.elements.matrixTitle.textContent = 'Probability Matrix';
                    } else {
                        currentMatrix = sampleData.scoreMatrix;
                        this.elements.matrixTitle.textContent = 'Score Matrix';
                        // If prob was selected but not available, fall back to score
                        if (this.matrixType === 'prob') {
                            this.setMatrixType('score');
                        }
                    }
                    
                    if (this.matrixMode === 'heatmap') {
                        this.updateHeatmap(currentMatrix);
                    } else {
                        this.updateLogo(currentMatrix);
                    }
                }
            }
            
            setMatrixType(type) {
                this.matrixType = type;
                
                // Update button states for matrix type
                document.querySelectorAll('.toggle-btn[data-type]').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.type === type);
                });
                
                // Update visualization if data is available
                if (this.data) {
                    const stepData = this.data.steps[this.currentStep];
                    const sampleData = {
                        sequence: stepData.sequences[this.currentSample],
                        scoreMatrix: stepData.score_matrices[this.currentSample],
                        probMatrix: stepData.prob_matrices ? stepData.prob_matrices[this.currentSample] : null,
                        oracleMse: stepData.oracle_mses[this.currentSample]
                    };
                    this.updateMatrix(sampleData);
                }
            }
            
            updateDualMatrices(sampleData) {
                if (this.matrixMode === 'heatmap') {
                    // Show heatmaps, hide logos
                    this.elements.scoreLogoContainer.classList.add('hidden');
                    this.elements.probLogoContainer.classList.add('hidden');
                    this.elements.scoreHeatmapContainer.classList.remove('hidden');
                    this.elements.probHeatmapContainer.classList.remove('hidden');
                    this.elements.scoreHeatmapLegend.classList.remove('hidden');
                    this.elements.probHeatmapLegend.classList.remove('hidden');
                    
                    // Update score matrix heatmap
                    this.updateHeatmapInContainer(sampleData.scoreMatrix, 'score', 
                        this.elements.scoreHeatmapContainer, this.elements.scoreHeatmapLegend);
                    
                    // Update prob matrix heatmap
                    this.updateHeatmapInContainer(sampleData.probMatrix, 'prob', 
                        this.elements.probHeatmapContainer, this.elements.probHeatmapLegend);
                    
                    // Set up synchronized scrolling for heatmaps
                    this.setupSynchronizedScrolling(this.elements.scoreHeatmapContainer.parentElement, 
                        this.elements.probHeatmapContainer.parentElement);
                } else {
                    // Show logos, hide heatmaps
                    this.elements.scoreHeatmapContainer.classList.add('hidden');
                    this.elements.probHeatmapContainer.classList.add('hidden');
                    this.elements.scoreHeatmapLegend.classList.add('hidden');
                    this.elements.probHeatmapLegend.classList.add('hidden');
                    this.elements.scoreLogoContainer.classList.remove('hidden');
                    this.elements.probLogoContainer.classList.remove('hidden');
                    
                    // Update score matrix logo
                    this.updateLogoInContainer(sampleData.scoreMatrix, 'score', 
                        this.elements.scoreLogoContainer);
                    
                    // Update prob matrix logo
                    this.updateLogoInContainer(sampleData.probMatrix, 'prob', 
                        this.elements.probLogoContainer);
                    
                    // Set up synchronized scrolling for logos
                    this.setupSynchronizedScrolling(this.elements.scoreLogoContainer.parentElement, 
                        this.elements.probLogoContainer.parentElement);
                }
            }
            
            setupSynchronizedScrolling(container1, container2) {
                // Remove any existing scroll listeners to avoid duplicates
                this.removeSynchronizedScrolling();
                
                // Create scroll synchronization handlers
                const syncScroll1 = (event) => {
                    if (!this.isScrollingSyncronized) {
                        this.isScrollingSyncronized = true;
                        container2.scrollLeft = container1.scrollLeft;
                        setTimeout(() => { this.isScrollingSyncronized = false; }, 10);
                    }
                };
                
                const syncScroll2 = (event) => {
                    if (!this.isScrollingSyncronized) {
                        this.isScrollingSyncronized = true;
                        container1.scrollLeft = container2.scrollLeft;
                        setTimeout(() => { this.isScrollingSyncronized = false; }, 10);
                    }
                };
                
                // Add scroll listeners
                container1.addEventListener('scroll', syncScroll1);
                container2.addEventListener('scroll', syncScroll2);
                
                // Store references for cleanup
                this.scrollHandlers = [
                    { element: container1, handler: syncScroll1 },
                    { element: container2, handler: syncScroll2 }
                ];
            }
            
            removeSynchronizedScrolling() {
                if (this.scrollHandlers) {
                    this.scrollHandlers.forEach(({ element, handler }) => {
                        element.removeEventListener('scroll', handler);
                    });
                    this.scrollHandlers = null;
                }
            }
            
            updateHeatmap(matrix) {
                this.updateHeatmapInContainer(matrix, this.matrixType, this.elements.heatmapContainer, this.elements.heatmapLegend);
            }
            
            updateLogo(matrix) {
                this.updateLogoInContainer(matrix, this.matrixType, this.elements.logoContainer);
            }
            
            updateHeatmapInContainer(matrix, matrixType, container, legendContainer) {
                container.innerHTML = '';
                
                const cellSize = 12;
                const baseLabels = ['A', 'C', 'G', 'T'];
                
                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', matrix.length * cellSize + 40)
                    .attr('height', 4 * cellSize + 40);
                
                // Create appropriate color scale based on matrix type
                let colorScale, valueLabel;
                if (matrixType === 'prob') {
                    // For probability matrix: 0 (blue) to 1 (red)
                    colorScale = d3.scaleSequential(d3.interpolateRdBu)
                        .domain([1, 0]); // Reversed: 1=red (high prob), 0=blue (low prob)
                    valueLabel = 'Probability';
                } else {
                    // For score matrix: keep original scale
                    colorScale = d3.scaleSequential(d3.interpolateRdBu)
                        .domain([2, 0]); // 1 is now in the middle (white), 2=blue (low), 0=red (high)
                    valueLabel = 'Score';
                }
                
                // Get tooltip element
                const tooltip = d3.select('#tooltip');
                
                // Add base labels
                svg.selectAll('.base-label')
                    .data(baseLabels)
                    .enter()
                    .append('text')
                    .attr('class', 'base-label')
                    .attr('x', 15)
                    .attr('y', (d, i) => 25 + i * cellSize)
                    .attr('text-anchor', 'middle')
                    .attr('dominant-baseline', 'central')
                    .style('fill', this.theme === 'dark' ? '#888' : '#6c757d')
                    .style('font-size', '10px')
                    .text(d => d);
                
                // Add cells with hover tooltips and selection functionality
                matrix.forEach((position, posIndex) => {
                    position.forEach((value, baseIndex) => {
                        const rect = svg.append('rect')
                            .attr('x', 30 + posIndex * cellSize)
                            .attr('y', 15 + baseIndex * cellSize)
                            .attr('width', cellSize - 1)
                            .attr('height', cellSize - 1)
                            .style('fill', colorScale(value))
                            .style('cursor', this.selectionMode ? 'crosshair' : 'pointer')
                            .attr('data-position', posIndex)
                            .attr('data-base', baseIndex);
                            
                        // Add highlight border if this position is highlighted
                        if (this.highlightedPosition === posIndex) {
                            rect.style('stroke', '#00d4ff')
                                .style('stroke-width', '2px')
                                .style('stroke-dasharray', '2,2');
                        }
                        
                        // Individual cell highlighting removed - only outer rectangle selection is shown
                        
                        if (this.selectionMode) {
                            // Selection mode event handlers
                            rect.on('mousedown', (event) => {
                                event.preventDefault();
                                this.startSelection(posIndex, container);
                            })
                            .on('mouseover', (event) => {
                                if (this.isSelecting) {
                                    this.updateSelectionEnd(posIndex, container);
                                }
                                // Still show tooltip in selection mode
                                tooltip
                                    .style('opacity', 1)
                                    .html(`Position: ${posIndex + 1}<br/>Base: ${baseLabels[baseIndex]}<br/>${valueLabel}: ${value.toFixed(4)}`)
                                    .style('left', (event.pageX + 10) + 'px')
                                    .style('top', (event.pageY - 10) + 'px');
                            })
                            .on('mouseout', function() {
                                tooltip.style('opacity', 0);
                            });
                        } else {
                            // Normal mode event handlers
                            rect.on('mouseover', function(event) {
                                    tooltip
                                        .style('opacity', 1)
                                        .html(`Position: ${posIndex + 1}<br/>Base: ${baseLabels[baseIndex]}<br/>${valueLabel}: ${value.toFixed(4)}`)
                                        .style('left', (event.pageX + 10) + 'px')
                                        .style('top', (event.pageY - 10) + 'px');
                                })
                                .on('mousemove', function(event) {
                                    tooltip
                                        .style('left', (event.pageX + 10) + 'px')
                                        .style('top', (event.pageY - 10) + 'px');
                                })
                                .on('mouseout', function() {
                                    tooltip.style('opacity', 0);
                                })
                                .on('click', (event) => {
                                    event.stopPropagation();
                                    this.toggleNucleotideHighlight(posIndex);
                                });
                        }
                    });
                });
                
                // Add permanent selection overlay to SVG if there's a selection
                if (this.selectedRange && this.selectedRange.start !== null && this.selectedRange.end !== null) {
                    const start = Math.min(this.selectedRange.start, this.selectedRange.end);
                    const end = Math.max(this.selectedRange.start, this.selectedRange.end);
                    
                    svg.append('rect')
                        .attr('class', 'selection-overlay-permanent')
                        .attr('x', 30 + start * cellSize)
                        .attr('y', 15)
                        .attr('width', (end - start + 1) * cellSize)
                        .attr('height', 4 * cellSize)
                        .style('fill', 'rgba(251, 146, 60, 0.15)')
                        .style('stroke', '#fb923c')
                        .style('stroke-width', '2px')
                        .style('stroke-dasharray', '3,3')
                        .style('pointer-events', 'none');
                }
                
                // Create color legend
                if (legendContainer) {
                    this.createMatrixLegend(legendContainer, colorScale, valueLabel, matrixType);
                }
            }
            
            updateLogoInContainer(matrix, matrixType, container) {
                container.innerHTML = '';
                
                // Validate and process matrix for information content (bits mode)
                let processedMatrix = [];
                try {
                    // Check if matrix is valid
                    if (!Array.isArray(matrix) || matrix.length === 0) {
                        throw new Error('Invalid matrix format');
                    }
                    
                    // Process matrix based on type
                    processedMatrix = matrix.map((position, idx) => {
                        if (!Array.isArray(position) || position.length !== 4) {
                            console.warn(`Invalid position at index ${idx}:`, position);
                            return [0.25, 0.25, 0.25, 0.25]; // Default equal distribution
                        }
                        
                        if (matrixType === 'prob') {
                            // For probability matrix, values should already be probabilities
                            // Just ensure they're valid and sum to 1
                            const cleanPosition = position.map(val => Math.max(0, val || 0));
                            const total = cleanPosition.reduce((a, b) => a + b, 0);
                            
                            if (total === 0) {
                                return [0.25, 0.25, 0.25, 0.25]; // Default equal distribution
                            }
                            
                            // Normalize to ensure sum = 1
                            return cleanPosition.map(val => val / total);
                        } else {
                            // For score matrix, convert to probabilities
                            // Ensure all values are non-negative
                            const cleanPosition = position.map(val => Math.max(0, val || 0));
                            const total = cleanPosition.reduce((a, b) => a + b, 0);
                            
                            if (total === 0) {
                                return [0.25, 0.25, 0.25, 0.25]; // Default equal distribution
                            }
                            
                            // Simple normalization - convert to probabilities
                            return cleanPosition.map(val => val / total);
                        }
                    });
                } catch (error) {
                    console.error('Error processing matrix for logo:', error);
                    container.innerHTML = this.createFallbackLogo(matrix);
                    return;
                }
                
                // Create a div for the logo
                const logoDiv = document.createElement('div');
                logoDiv.id = 'dna-logo-' + Date.now();
                container.appendChild(logoDiv);
                
                // Get theme-appropriate colors for DNA bases
                const themeColors = this.getThemeBasesColors();
                
                // Create custom DNA alphabet with theme colors
                const customAlphabet = [
                    {regex: 'A', color: themeColors.A, component: logojs.A},
                    {regex: 'C', color: themeColors.C, component: logojs.C}, 
                    {regex: 'G', color: themeColors.G, component: logojs.G},
                    {regex: 'T', color: themeColors.T, component: logojs.T}
                ];
                
                // Configure logojs with perfect size - no width limits!
                const logoWidth = processedMatrix.length * 20 + 100;
                const logoConfig = {
                    ppm: processedMatrix,
                    alphabet: customAlphabet,
                    width: logoWidth,
                    height: 200,
                    mode: 'INFORMATION_CONTENT',
                    // Add theme-aware styling
                    style: {
                        textColor: this.theme === 'dark' ? '#ffffff' : '#6c757d',
                        axisColor: this.theme === 'dark' ? '#ffffff' : '#6c757d',
                        gridColor: this.theme === 'dark' ? '#333' : '#dee2e6'
                    }
                };
                
                // Use LogoJS to create the logo
                if (typeof logojs === 'undefined') {
                    container.innerHTML = this.createFallbackLogo(matrix);
                    return;
                }
                
                try {
                    // Use the React component directly from the bundle
                    if (logojs.embedLogo) {
                        logojs.embedLogo(logoDiv, logoConfig);
                    } else if (logojs.embedDNALogo) {
                        logojs.embedDNALogo(logoDiv, logoConfig);
                    } else {
                        // Fallback to simple text display
                        container.innerHTML = this.createFallbackLogo(matrix);
                    }
                } catch (error) {
                    console.error('Error creating logo:', error);
                    container.innerHTML = this.createFallbackLogo(matrix);
                }
                
                // Add selection overlay for logo mode
                this.addLogoSelectionOverlay(container, matrix);
            }
            
            getThemeBasesColors() {
                // Get current theme colors from CSS variables
                const style = getComputedStyle(document.documentElement);
                return {
                    A: style.getPropertyValue('--base-a-color').trim(),
                    C: style.getPropertyValue('--base-c-color').trim(),
                    G: style.getPropertyValue('--base-g-color').trim(),
                    T: style.getPropertyValue('--base-t-color').trim()
                };
            }
            
            addLogoSelectionOverlay(container, matrix) {
                // Always add overlay for logo mode to enable selection functionality
                // (Remove the early return that was preventing overlay creation in logo mode)
                
                // Create invisible overlay for position-based selection
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    z-index: 5;
                    cursor: ${this.selectionMode ? 'crosshair' : 'pointer'};
                `;
                
                container.style.position = 'relative';
                
                // Calculate precise position mapping by examining the actual logo SVG
                const logoDiv = container.querySelector('div[id^="dna-logo-"]');
                let positionWidth = 20; // Default fallback
                let leftOffset = 50;    // Default fallback
                
                if (logoDiv && logoDiv.firstChild && logoDiv.firstChild.tagName === 'svg') {
                    const svg = logoDiv.firstChild;
                    const svgWidth = parseFloat(svg.getAttribute('width')) || (matrix.length * 20 + 100);
                    const matrixLength = matrix.length;
                    
                    // Calculate actual position width and offset based on SVG dimensions
                    // LogoJS typically uses some padding and spacing
                    const availableWidth = svgWidth - 100; // Subtract typical padding
                    positionWidth = availableWidth / matrixLength;
                    leftOffset = 50; // Standard logojs left padding
                }
                
                container.appendChild(overlay);
                const matrixLength = matrix.length;
                
                // Add invisible position zones
                for (let posIndex = 0; posIndex < matrixLength; posIndex++) {
                    const positionZone = document.createElement('div');
                    positionZone.style.cssText = `
                        position: absolute;
                        left: ${leftOffset + posIndex * positionWidth}px;
                        top: 0;
                        width: ${positionWidth}px;
                        height: 100%;
                        z-index: 6;
                    `;
                    
                    positionZone.setAttribute('data-position', posIndex);
                    
                    // Add highlight if this position is selected
                    if (this.highlightedPosition === posIndex) {
                        positionZone.style.background = 'rgba(0, 212, 255, 0.3)';
                    }
                    
                    if (this.selectionMode) {
                        // Selection mode event handlers
                        positionZone.addEventListener('mousedown', (event) => {
                            event.preventDefault();
                            this.startLogoSelection(posIndex, container, leftOffset, positionWidth);
                        });
                        
                        positionZone.addEventListener('mouseover', (event) => {
                            if (this.isSelecting) {
                                this.updateLogoSelectionEnd(posIndex, container, leftOffset, positionWidth);
                            }
                        });
                    } else {
                        // Normal mode - position highlighting
                        positionZone.addEventListener('click', (event) => {
                            event.stopPropagation();
                            this.toggleNucleotideHighlight(posIndex);
                        });
                    }
                    
                    overlay.appendChild(positionZone);
                }
                
                // Add permanent selection overlay if there's a selection
                if (this.selectedRange && this.selectedRange.start !== null && this.selectedRange.end !== null) {
                    const start = Math.min(this.selectedRange.start, this.selectedRange.end);
                    const end = Math.max(this.selectedRange.start, this.selectedRange.end);
                    
                    const selectionOverlay = document.createElement('div');
                    selectionOverlay.className = 'logo-permanent-selection';
                    selectionOverlay.style.cssText = `
                        position: absolute;
                        left: ${leftOffset + start * positionWidth}px;
                        top: 20px;
                        width: ${(end - start + 1) * positionWidth}px;
                        height: calc(100% - 40px);
                        background: rgba(251, 146, 60, 0.15);
                        border: 2px dashed #fb923c;
                        border-radius: 4px;
                        pointer-events: none;
                        z-index: 4;
                    `;
                    
                    container.appendChild(selectionOverlay);
                }
            }
            
            createFallbackLogo(scoreMatrix) {
                if (!Array.isArray(scoreMatrix) || scoreMatrix.length === 0) {
                    return '<div style="color: #888; text-align: center; padding: 40px;">Invalid score matrix data</div>';
                }
                
                const baseLetters = ['A', 'C', 'G', 'T'];
                const themeColors = this.getThemeBasesColors();
                const baseColors = [themeColors.A, themeColors.C, themeColors.G, themeColors.T];
                
                let html = '<div style="font-family: monospace; font-size: 14px; text-align: center; padding: 20px; color: #888;">';
                html += '<div style="margin-bottom: 10px;">Sequence Logo (Fallback)</div>';
                html += '<div style="display: flex; gap: 2px; justify-content: center; flex-wrap: wrap; max-width: 100%; overflow-x: auto;">';
                
                for (let i = 0; i < Math.min(scoreMatrix.length, 60); i++) {
                    const position = scoreMatrix[i];
                    
                    if (!Array.isArray(position) || position.length !== 4) {
                        html += '<span style="color: #666;">?</span>';
                        continue;
                    }
                    
                    // Normalize position to probabilities
                    const cleanPosition = position.map(val => Math.max(0, val || 0));
                    const total = cleanPosition.reduce((a, b) => a + b, 0);
                    
                    if (total > 0) {
                        const normalized = cleanPosition.map(val => val / total);
                        
                        // Find the most probable base
                        let maxIdx = 0;
                        let maxVal = normalized[0];
                        for (let j = 1; j < normalized.length; j++) {
                            if (normalized[j] > maxVal) {
                                maxVal = normalized[j];
                                maxIdx = j;
                            }
                        }
                        
                        const confidence = maxVal;
                        const opacity = Math.max(0.3, confidence); // Scale opacity by confidence
                        const fontSize = Math.max(10, 14 * confidence); // Scale size by confidence
                        
                        html += `<span style="color: ${baseColors[maxIdx]}; opacity: ${opacity}; font-weight: bold; font-size: ${fontSize}px;">${baseLetters[maxIdx]}</span>`;
                    } else {
                        html += '<span style="color: #666;">N</span>';
                    }
                }
                
                html += '</div>';
                html += '<div style="font-size: 10px; margin-top: 10px; color: #666;">LogoJS unavailable - showing consensus sequence</div>';
                html += '</div>';
                
                return html;
            }
            
            createFallbackLogo(scoreMatrix) {
                if (!Array.isArray(scoreMatrix) || scoreMatrix.length === 0) {
                    return '<div style="color: #888; text-align: center; padding: 40px;">Invalid score matrix data</div>';
                }
                
                const baseLetters = ['A', 'C', 'G', 'T'];
                const themeColors = this.getThemeBasesColors();
                const baseColors = [themeColors.A, themeColors.C, themeColors.G, themeColors.T];
                
                let html = '<div style="font-family: monospace; font-size: 14px; text-align: center; padding: 20px; color: #888;">';
                html += '<div style="margin-bottom: 10px;">Sequence Logo (Fallback)</div>';
                html += '<div style="display: flex; gap: 2px; justify-content: center; flex-wrap: wrap; max-width: 100%; overflow-x: auto;">';
                
                for (let i = 0; i < Math.min(scoreMatrix.length, 60); i++) {
                    const position = scoreMatrix[i];
                    
                    if (!Array.isArray(position) || position.length !== 4) {
                        html += '<span style="color: #666;">?</span>';
                        continue;
                    }
                    
                    // Normalize position to probabilities
                    const cleanPosition = position.map(val => Math.max(0, val || 0));
                    const total = cleanPosition.reduce((a, b) => a + b, 0);
                    
                    if (total > 0) {
                        const normalized = cleanPosition.map(val => val / total);
                        
                        // Find the most probable base
                        let maxIdx = 0;
                        let maxVal = normalized[0];
                        for (let j = 1; j < normalized.length; j++) {
                            if (normalized[j] > maxVal) {
                                maxVal = normalized[j];
                                maxIdx = j;
                            }
                        }
                        
                        const confidence = maxVal;
                        const opacity = Math.max(0.3, confidence); // Scale opacity by confidence
                        const fontSize = Math.max(10, 14 * confidence); // Scale size by confidence
                        
                        html += `<span style="color: ${baseColors[maxIdx]}; opacity: ${opacity}; font-weight: bold; font-size: ${fontSize}px;">${baseLetters[maxIdx]}</span>`;
                    } else {
                        html += '<span style="color: #666;">N</span>';
                    }
                }
                
                html += '</div>';
                html += '<div style="font-size: 10px; margin-top: 10px; color: #666;">LogoJS unavailable - showing consensus sequence</div>';
                html += '</div>';
                
                return html;
            }
            
            setMatrixMode(mode) {
                this.matrixMode = mode;
                
                // Update button states for mode
                document.querySelectorAll('.toggle-btn[data-mode]').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === mode);
                });
                
                // Update CSS classes for height adjustment
                const matrixSection = document.querySelector('.score-matrix-section');
                if (this.matrixType === 'both') {
                    if (mode === 'logo') {
                        matrixSection.classList.add('logo-mode');
                    } else {
                        matrixSection.classList.remove('logo-mode');
                    }
                }
                
                // Toggle containers for single matrix mode
                this.elements.heatmapContainer.classList.toggle('hidden', mode !== 'heatmap');
                this.elements.logoContainer.classList.toggle('hidden', mode !== 'logo');
                this.elements.heatmapLegend.classList.toggle('hidden', mode !== 'heatmap');
                
                // Update visualization
                if (this.data) {
                    const stepData = this.data.steps[this.currentStep];
                    const sampleData = {
                        sequence: stepData.sequences[this.currentSample],
                        scoreMatrix: stepData.score_matrices[this.currentSample],
                        probMatrix: stepData.prob_matrices ? stepData.prob_matrices[this.currentSample] : null,
                        oracleMse: stepData.oracle_mses[this.currentSample]
                    };
                    this.updateMatrix(sampleData);
                }
            }
            
            initializeCharts() {
                const getChartOptions = () => ({
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { 
                            grid: { color: this.theme === 'dark' ? '#333' : '#dee2e6' },
                            ticks: { color: this.theme === 'dark' ? '#888' : '#6c757d' }
                        },
                        y: { 
                            grid: { color: this.theme === 'dark' ? '#333' : '#dee2e6' },
                            ticks: { color: this.theme === 'dark' ? '#888' : '#6c757d' }
                        }
                    },
                    plugins: {
                        legend: { display: false }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    onClick: (event, elements, chart) => {
                        if (elements.length > 0) {
                            // Get the x-axis value (step) from the clicked point
                            const dataIndex = elements[0].index;
                            if (dataIndex !== undefined && dataIndex >= 0) {
                                this.setStep(dataIndex);
                            }
                        } else {
                            // If no elements are clicked, try to get the step from the x-axis position
                            const canvasPosition = Chart.helpers.getRelativePosition(event, chart);
                            const dataX = chart.scales.x.getValueForPixel(canvasPosition.x);
                            if (dataX !== undefined && dataX >= 0) {
                                const step = Math.round(dataX);
                                if (step >= 0 && step < this.data.metadata.total_steps) {
                                    this.setStep(step);
                                }
                            }
                        }
                    },
                    onHover: (event, elements, chart) => {
                        chart.canvas.style.cursor = elements.length > 0 ? 'pointer' : 'default';
                    }
                });
                
                // Initialize charts with error handling
                try {
                    // MSE Chart
                    const mseElement = document.getElementById('mseChart');
                    if (mseElement) {
                        this.charts.mse = new Chart(mseElement, {
                            type: 'line',
                            data: { datasets: [] },
                            options: getChartOptions()
                        });
                    }
                } catch (error) {
                    console.warn('Failed to initialize MSE chart:', error);
                }
                
                try {
                    // Noise Level Chart
                    const noiseElement = document.getElementById('noiseChart');
                    if (noiseElement) {
                        this.charts.noise = new Chart(noiseElement, {
                            type: 'line',
                            data: { datasets: [] },
                            options: getChartOptions()
                        });
                    }
                } catch (error) {
                    console.warn('Failed to initialize noise chart:', error);
                }
                
                try {
                    // Noise Rate Chart
                    const rateElement = document.getElementById('rateChart');
                    if (rateElement) {
                        this.charts.rate = new Chart(rateElement, {
                            type: 'line',
                            data: { datasets: [] },
                            options: getChartOptions()
                        });
                    }
                } catch (error) {
                    console.warn('Failed to initialize rate chart:', error);
                }
                
                try {
                    // Nucleotide Changes Chart
                    const changesElement = document.getElementById('changesChart');
                    if (changesElement) {
                        this.charts.changes = new Chart(changesElement, {
                            type: 'line',
                            data: { datasets: [] },
                            options: getChartOptions()
                        });
                    }
                } catch (error) {
                    console.warn('Failed to initialize changes chart:', error);
                }
            }
            
            calculateNucleotideChanges(sampleIndex) {
                if (!this.data || this.data.steps.length < 2) return [];
                
                const changes = [];
                
                // First step has no previous step to compare to, so 0 changes
                changes.push(0);
                
                // Calculate changes for each subsequent step
                for (let stepIndex = 1; stepIndex < this.data.steps.length; stepIndex++) {
                    const currentSequence = this.data.steps[stepIndex].sequences[sampleIndex];
                    const previousSequence = this.data.steps[stepIndex - 1].sequences[sampleIndex];
                    
                    let changeCount = 0;
                    
                    // Compare each nucleotide position
                    for (let i = 0; i < currentSequence.length; i++) {
                        if (currentSequence[i] !== previousSequence[i]) {
                            changeCount++;
                        }
                    }
                    
                    changes.push(changeCount);
                }
                
                return changes;
            }
            
            calculateScoreChanges(sampleIndex) {
                if (!this.data || this.data.steps.length < 2) return [];
                
                const changes = [];
                
                // First step has no previous step to compare to, so 0 change
                changes.push(0);
                
                // Calculate score changes for each subsequent step
                for (let stepIndex = 1; stepIndex < this.data.steps.length; stepIndex++) {
                    const currentScoreMatrix = this.data.steps[stepIndex].score_matrices[sampleIndex];
                    const previousScoreMatrix = this.data.steps[stepIndex - 1].score_matrices[sampleIndex];
                    
                    let totalChange = 0;
                    let positionCount = 0;
                    
                    // Compare each base pair position
                    for (let i = 0; i < currentScoreMatrix.length; i++) {
                        // Get raw scores for this position
                        const currentRaw = [
                            currentScoreMatrix[i][0] || 0,
                            currentScoreMatrix[i][1] || 0,
                            currentScoreMatrix[i][2] || 0,
                            currentScoreMatrix[i][3] || 0
                        ];
                        const previousRaw = [
                            previousScoreMatrix[i][0] || 0,
                            previousScoreMatrix[i][1] || 0,
                            previousScoreMatrix[i][2] || 0,
                            previousScoreMatrix[i][3] || 0
                        ];
                        
                        // NORMALIZE: Convert to probabilities (sum = 1) for each position
                        const currentSum = currentRaw.reduce((a, b) => a + Math.max(0, b), 0);
                        const previousSum = previousRaw.reduce((a, b) => a + Math.max(0, b), 0);
                        
                        const currentNorm = currentSum > 0 ? 
                            currentRaw.map(val => Math.max(0, val) / currentSum) : 
                            [0.25, 0.25, 0.25, 0.25]; // Equal if sum is 0
                        const previousNorm = previousSum > 0 ? 
                            previousRaw.map(val => Math.max(0, val) / previousSum) : 
                            [0.25, 0.25, 0.25, 0.25]; // Equal if sum is 0
                        
                        // Calculate position change using normalized values
                        let positionChange = 0;
                        for (let j = 0; j < 4; j++) {
                            positionChange += Math.abs(currentNorm[j] - previousNorm[j]);
                        }
                        
                        totalChange += positionChange;
                        positionCount++;
                    }
                    
                    // Calculate average change across all positions
                    const averageChange = positionCount > 0 ? totalChange / positionCount : 0;
                    changes.push(averageChange);
                }
                
                return changes;
            }
            
            updateCharts() {
                if (!this.data) return;
                
                const steps = this.data.steps.map(step => step.step);
                const mseData = this.data.steps.map(step => step.oracle_mses[this.currentSample]);
                const noiseData = this.data.steps.map(step => step.noise_level);
                const scoreChangeData = this.calculateScoreChanges(this.currentSample);
                const changesData = this.calculateNucleotideChanges(this.currentSample);
                
                // Update MSE chart
                if (this.charts.mse) {
                    this.charts.mse.data = {
                        labels: steps,
                        datasets: [{
                            data: mseData,
                            borderColor: '#00d4ff',
                            backgroundColor: 'rgba(0, 212, 255, 0.1)',
                            fill: true,
                            tension: 0.4,
                            pointRadius: 0,
                            pointHoverRadius: 4
                        }]
                    };
                }
                
                // Update Noise Level chart
                if (this.charts.noise) {
                    this.charts.noise.data = {
                        labels: steps,
                        datasets: [{
                            data: noiseData,
                            borderColor: '#ff6b6b',
                            backgroundColor: 'rgba(255, 107, 107, 0.1)',
                            fill: true,
                            tension: 0.4,
                            pointRadius: 0,
                            pointHoverRadius: 4
                        }]
                    };
                }
                
                // Update Score Change chart
                if (this.charts.rate) {
                    this.charts.rate.data = {
                        labels: steps,
                        datasets: [{
                            data: scoreChangeData,
                            borderColor: '#96ceb4',
                            backgroundColor: 'rgba(150, 206, 180, 0.1)',
                            fill: true,
                            tension: 0.4,
                            pointRadius: 0,
                            pointHoverRadius: 4
                        }]
                    };
                }
                
                // Update Nucleotide Changes chart
                if (this.charts.changes) {
                    this.charts.changes.data = {
                        labels: steps,
                        datasets: [{
                            data: changesData,
                            borderColor: '#4ecdc4',
                            backgroundColor: 'rgba(78, 205, 196, 0.1)',
                            fill: true,
                            tension: 0.4,
                            pointRadius: 0,
                            pointHoverRadius: 4
                        }]
                    };
                }
                
                // Update all charts (excluding predictions object)
                if (this.charts) {
                    Object.entries(this.charts).forEach(([key, chart]) => {
                        if (key === 'predictions' || !chart || !chart.update || typeof chart.update !== 'function') return;
                        chart.update('none');
                    });
                }
                
                this.updateChartProgress();
                
                // Update prediction charts if they exist
                if (this.charts.predictions) {
                    this.updatePredictionCharts();
                }
            }
            
            updateChartProgress() {
                // Add current step indicator to charts (excluding predictions object)
                if (!this.charts) return;
                
                Object.entries(this.charts).forEach(([key, chart]) => {
                    // Skip the predictions object as it's not a chart itself
                    if (key === 'predictions' || !chart || !chart.data || !chart.data.datasets || !Array.isArray(chart.data.datasets)) return;
                    
                    // Remove existing progress line
                    if (chart.data.datasets[1]) {
                        chart.data.datasets.pop();
                    }
                    
                    // Theme-aware progress indicator colors
                    const progressColors = this.theme === 'dark' 
                        ? { border: '#ffffff', background: '#ffffff' }
                        : { border: '#212529', background: '#ffffff' };
                    
                    // Add progress line if we have data for the current step
                    if (chart.data.datasets[0] && chart.data.datasets[0].data[this.currentStep] !== undefined) {
                        chart.data.datasets.push({
                            type: 'scatter',
                            data: [{
                                x: this.currentStep,
                                y: chart.data.datasets[0].data[this.currentStep]
                            }],
                            borderColor: progressColors.border,
                            backgroundColor: progressColors.background,
                            borderWidth: 2,
                            pointRadius: 6,
                            pointHoverRadius: 8,
                            showLine: false,
                            order: -1 // Render this dataset on top of others
                        });
                    }
                    
                    chart.update('none');
                });
                
                // Update prediction chart progress if they exist
                if (this.charts.predictions) {
                    this.updatePredictionChartProgress();
                }
            }
            
            clearPredictionPlots() {
                // Remove any existing prediction plot sections from the grid
                if (this.elements.visualizationGrid) {
                    const existingPredictionSections = this.elements.visualizationGrid.querySelectorAll('[id^="predictionPlot"][id$="Section"]');
                    existingPredictionSections.forEach(section => section.remove());
                }
                
                // Clear prediction charts object
                if (this.charts.predictions) {
                    Object.values(this.charts.predictions).forEach(chart => {
                        if (chart && chart.destroy) {
                            chart.destroy();
                        }
                    });
                    this.charts.predictions = {};
                }
            }
            
            setupPredictionPlots() {
                if (!this.data || !this.data.metadata || !this.data.metadata.ground_truth_labels || 
                    !this.data.steps || this.data.steps.length === 0 || !this.data.steps[0].oracle_predictions) return;
                
                // Clear any existing prediction plots first
                this.clearPredictionPlots();
                
                const numLabels = this.data.metadata.ground_truth_labels[0].length;
                
                // Initialize prediction charts object
                if (!this.charts.predictions) {
                    this.charts.predictions = {};
                }
                
                // Create a separate viz-section for each label and append to the grid
                for (let labelIndex = 0; labelIndex < numLabels; labelIndex++) {
                    // Create the viz-section element
                    const vizSection = document.createElement('div');
                    vizSection.className = 'viz-section';
                    vizSection.id = `predictionPlot${labelIndex}Section`;
                    
                    // Create the title
                    const titleDiv = document.createElement('div');
                    titleDiv.className = 'viz-title';
                    titleDiv.textContent = `Label ${labelIndex + 1} Predictions vs Steps`;
                    
                    // Create the chart container
                    const chartContainer = document.createElement('div');
                    chartContainer.className = 'chart-container';
                    
                    // Create the canvas
                    const canvas = document.createElement('canvas');
                    canvas.id = `predictionChart${labelIndex}`;
                    
                    // Assemble the structure
                    chartContainer.appendChild(canvas);
                    vizSection.appendChild(titleDiv);
                    vizSection.appendChild(chartContainer);
                    
                    // Append directly to the visualization grid (not a separate container)
                    this.elements.visualizationGrid.appendChild(vizSection);
                    
                    // Create chart with error handling
                    try {
                        this.charts.predictions[labelIndex] = new Chart(canvas, {
                            type: 'line',
                            data: { datasets: [] },
                            options: this.getPredictionChartOptions()
                        });
                    } catch (error) {
                        console.warn(`Failed to initialize prediction chart ${labelIndex}:`, error);
                    }
                }
                
                // Update prediction charts with initial data
                this.updatePredictionCharts();
            }
            
            getPredictionChartOptions() {
                return {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { 
                            grid: { color: this.theme === 'dark' ? '#333' : '#dee2e6' },
                            ticks: { color: this.theme === 'dark' ? '#888' : '#6c757d' },
                            title: { display: true, text: 'Steps', color: this.theme === 'dark' ? '#888' : '#6c757d' }
                        },
                        y: { 
                            grid: { color: this.theme === 'dark' ? '#333' : '#dee2e6' },
                            ticks: { color: this.theme === 'dark' ? '#888' : '#6c757d' },
                            title: { display: true, text: 'Prediction Value', color: this.theme === 'dark' ? '#888' : '#6c757d' }
                        }
                    },
                    plugins: {
                        legend: { 
                            display: true,
                            position: 'top',
                            labels: {
                                color: this.theme === 'dark' ? '#888' : '#6c757d',
                                usePointStyle: true,
                                pointStyle: 'rect',
                                boxWidth: 8,
                                boxHeight: 8,
                                padding: 15,
                                filter: function(legendItem) {
                                    // Hide "Current Step" from legend
                                    return legendItem.text !== 'Current Step';
                                }
                            }
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    onClick: (event, elements, chart) => {
                        if (elements.length > 0) {
                            const dataIndex = elements[0].index;
                            if (dataIndex !== undefined && dataIndex >= 0) {
                                this.setStep(dataIndex);
                            }
                        }
                    },
                    onHover: (event, elements, chart) => {
                        chart.canvas.style.cursor = elements.length > 0 ? 'pointer' : 'default';
                    }
                };
            }
            
            updatePredictionCharts() {
                if (!this.data || !this.data.metadata || !this.data.metadata.ground_truth_labels || 
                    !this.data.steps || this.data.steps.length === 0 || !this.data.steps[0].oracle_predictions || 
                    !this.charts.predictions) return;
                
                const steps = this.data.steps.map(step => step.step);
                const numLabels = this.data.metadata.ground_truth_labels[0].length;
                
                for (let labelIndex = 0; labelIndex < numLabels; labelIndex++) {
                    const chart = this.charts.predictions[labelIndex];
                    if (!chart) continue;
                    
                    // Get ground truth values for this label (constant across all samples at current sample)
                    const groundTruthLabel = this.data.metadata.ground_truth_labels[this.currentSample][labelIndex];
                    const groundTruthPrediction = this.data.metadata.ground_truth_predictions 
                        ? this.data.metadata.ground_truth_predictions[this.currentSample][labelIndex] 
                        : groundTruthLabel;
                    
                    // Get oracle predictions for this label across all steps
                    const oraclePredictions = this.data.steps.map(step => 
                        step.oracle_predictions[this.currentSample][labelIndex]
                    );
                    
                    // Create datasets
                    const datasets = [
                        // Oracle predictions (changing over steps)
                        {
                            label: 'Oracle Predictions',
                            data: oraclePredictions,
                            borderColor: '#00d4ff',
                            backgroundColor: 'rgba(0, 212, 255, 0.1)',
                            fill: false,
                            tension: 0.4,
                            pointRadius: 1,
                            pointHoverRadius: 4,
                            borderWidth: 2
                        },
                        // Ground truth predictions (horizontal dotted line)
                        {
                            label: 'Ground Truth Predictions',
                            data: steps.map(() => groundTruthPrediction),
                            borderColor: '#4ecdc4',
                            backgroundColor: 'rgba(78, 205, 196, 0.1)',
                            fill: false,
                            tension: 0,
                            pointRadius: 0,
                            pointHoverRadius: 2,
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        // Ground truth labels (horizontal dotted line)
                        {
                            label: 'Ground Truth Labels',
                            data: steps.map(() => groundTruthLabel),
                            borderColor: '#96ceb4',
                            backgroundColor: 'rgba(150, 206, 180, 0.1)',
                            fill: false,
                            tension: 0,
                            pointRadius: 0,
                            pointHoverRadius: 2,
                            borderWidth: 2,
                            borderDash: [10, 5]
                        }
                    ];
                    
                    chart.data = {
                        labels: steps,
                        datasets: datasets
                    };
                    
                    chart.update('none');
                }
                
                // Update progress indicators for prediction charts
                this.updatePredictionChartProgress();
            }
            
            updatePredictionChartProgress() {
                if (!this.charts.predictions) return;
                
                Object.values(this.charts.predictions).forEach(chart => {
                    // Remove existing progress line (if any)
                    const datasets = chart.data.datasets;
                    const progressDatasetIndex = datasets.findIndex(ds => ds.label === 'Current Step');
                    if (progressDatasetIndex !== -1) {
                        datasets.splice(progressDatasetIndex, 1);
                    }
                    
                    // Theme-aware progress indicator colors
                    const progressColors = this.theme === 'dark' 
                        ? { border: '#ffffff', background: '#ffffff' }
                        : { border: '#212529', background: '#ffffff' };
                    
                    // Add progress line for oracle predictions (first dataset)
                    if (datasets[0] && datasets[0].data[this.currentStep] !== undefined) {
                        datasets.push({
                            label: 'Current Step',
                            type: 'scatter',
                            data: [{
                                x: this.currentStep,
                                y: datasets[0].data[this.currentStep]
                            }],
                            borderColor: progressColors.border,
                            backgroundColor: progressColors.background,
                            borderWidth: 2,
                            pointRadius: 6,
                            pointHoverRadius: 8,
                            showLine: false,
                            order: -1
                        });
                    }
                    
                    chart.update('none');
                });
            }
            
            createMatrixLegend(container, colorScale, valueLabel = 'Score', matrixType) {
                container.innerHTML = '';
                
                // Generate unique ID for this gradient to avoid conflicts
                const uniqueId = `gradient-${matrixType}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                
                // Create legend HTML
                container.innerHTML = `
                    <div class="legend-labels">
                        <span>Low</span>
                        <span>${valueLabel}</span>
                        <span>High</span>
                    </div>
                    <div class="legend-gradient"></div>
                `;
                
                // Create SVG gradient for the legend
                const gradientSvg = d3.select(container)
                    .select('.legend-gradient')
                    .append('svg')
                    .attr('width', '100%')
                    .attr('height', '100%');
                
                // Define gradient with unique ID
                const gradient = gradientSvg.append('defs')
                    .append('linearGradient')
                    .attr('id', uniqueId)
                    .attr('x1', '0%')
                    .attr('x2', '100%');
                
                // Add color stops based on matrix type
                const stops = 20;
                for (let i = 0; i <= stops; i++) {
                    const t = i / stops;
                    let colorValue;
                    if (matrixType === 'prob') {
                        colorValue = colorScale(t); // For prob: 0 to 1
                    } else {
                        colorValue = colorScale(2*t); // For score: keep original scale
                    }
                    gradient.append('stop')
                        .attr('offset', `${t * 100}%`)
                        .attr('stop-color', colorValue);
                }
                
                // Apply gradient using the unique ID
                gradientSvg.append('rect')
                    .attr('width', '100%')
                    .attr('height', '100%')
                    .style('fill', `url(#${uniqueId})`);
            }
            
            togglePlay() {
                this.isPlaying = !this.isPlaying;
                
                if (this.isPlaying) {
                    this.elements.playIcon.textContent = '⏸';
                    this.play();
                } else {
                    this.elements.playIcon.textContent = '▶';
                    this.pause();
                }
            }
            
            play() {
                if (!this.data) return;
                
                const speed = parseInt(this.elements.speedSlider.value);
                const interval = Math.max(100, 1000 / speed);
                
                this.playInterval = setInterval(() => {
                    if (this.currentStep < this.data.metadata.total_steps - 1) {
                        this.setStep(this.currentStep + 1);
                    } else {
                        this.togglePlay(); // Auto-pause at end
                    }
                }, interval);
            }
            
            pause() {
                if (this.playInterval) {
                    clearInterval(this.playInterval);
                    this.playInterval = null;
                }
            }
            
            updatePlaySpeed() {
                // If currently playing, restart with new speed
                if (this.isPlaying) {
                    this.pause();
                    this.play();
                }
            }
            
            previousStep() {
                this.setStep(this.currentStep - 1);
            }
            
            nextStep() {
                this.setStep(this.currentStep + 1);
            }
            
            updatePositionAxis(sequenceLength) {
                if (!this.elements.positionAxis) return;
                
                let html = '';
                
                // Create the position axis with the same spacing pattern as the sequence
                for (let i = 0; i < sequenceLength; i++) {
                    // Show position numbers every 10 bases (0, 10, 20, 30, etc.)
                    if (i % 10 === 0) {
                        // Add the position number as a string
                        const positionStr = i.toString();
                        html += `<span style="display: inline-block; width: 1ch; text-align: center;">${positionStr.charAt(0)}</span>`;
                        
                        // Add remaining digits of multi-digit numbers
                        for (let j = 1; j < positionStr.length; j++) {
                            if (i + j < sequenceLength) {
                                html += `<span style="display: inline-block; width: 1ch; text-align: center;">${positionStr.charAt(j)}</span>`;
                                i++; // Skip ahead for multi-digit numbers
                            }
                        }
                    } else {
                        // Add empty space to maintain alignment
                        html += `<span style="display: inline-block; width: 1.285ch;">&nbsp;</span>`;
                    }
                    
                    // Add the same spacing as the sequence (space every 10 bases)
                    if ((i + 1) % 10 === 0 && i + 1 < sequenceLength) {
                        html += ' ';
                    }
                }
                
                this.elements.positionAxis.innerHTML = html;
            }
        }
        
        // Initialize the visualizer when the page loads
        let app; // Global reference for inline event handlers
        document.addEventListener('DOMContentLoaded', () => {
            app = new DNADiffusionVisualizer();
        });
    </script>
</body>
</html>