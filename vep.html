<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CAGI5 Variant Effect Prediction Visualizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/h5wasm@0.4.9/dist/esm/hdf5.js"></script>
    <script src="bundle.js" type="text/javascript"></script>
    <script src="memesuite-lite-js/memesuite-lite.js" type="text/javascript"></script>
    <style>
        /* Theme variables */
        :root {
            /* Dark theme (default) */
            --bg-primary: #0a0a0a;
            --bg-secondary: #1a1a1a;
            --bg-tertiary: #1e1e1e;
            --bg-quaternary: #0f0f0f;
            --text-primary: #ffffff;
            --text-secondary: #888;
            --accent-primary: #00d4ff;
            --accent-secondary: #ff6b6b;
            --accent-tertiary: #96ceb4;
            --border-color: #333;
            --input-bg: #333;
            --input-hover-bg: #555;
            --base-a-color: #ff6b6b;
            --base-c-color: #4ecdc4;
            --base-g-color: #45b7d1;
            --base-t-color: #96ceb4;
        }
        
        [data-theme="light"] {
            /* Light theme */
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-tertiary: #e9ecef;
            --bg-quaternary: #f5f5f5;
            --text-primary: #212529;
            --text-secondary: #6c757d;
            --accent-primary: #0056b3;
            --accent-secondary: #dc3545;
            --accent-tertiary: #198754;
            --border-color: #dee2e6;
            --input-bg: #e9ecef;
            --input-hover-bg: #dee2e6;
            --base-a-color: #d63031;
            --base-c-color: #00b894;
            --base-g-color: #0984e3;
            --base-t-color: #00a085;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        .container {
            display: grid;
            grid-template-columns: 300px 1fr;
            grid-template-rows: 60px 1fr 80px;
            height: 100vh;
            gap: 1px;
            background: var(--bg-secondary);
        }
        
        .header {
            grid-column: 1 / -1;
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            padding: 0 20px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .header h1 {
            font-size: 20px;
            font-weight: 600;
            color: var(--accent-primary);
        }
        
        .sidebar {
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }
        
        .main-panel {
            background: var(--bg-quaternary);
            overflow: hidden;
            padding: 16px;
            display: flex;
            flex-direction: column;
            min-width: 0;
            max-width: 100%;
        }
        
        .controls {
            grid-column: 1 / -1;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 15px;
            position: sticky;
            bottom: 0;
            z-index: 100;
        }
        
        /* Sidebar Styles */
        .sidebar-section {
            padding: 15px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .sidebar-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 10px;
        }
        
        .variant-list {
            flex: 1;
            overflow-y: auto;
            max-height: var(--sidebar-content-height, 500px);
            padding-bottom: 120px;
        }
        
        .variant-item {
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            margin-bottom: 2px;
            transition: all 0.2s ease;
            font-size: 12px;
            border: 1px solid transparent;
            background: var(--bg-tertiary);
        }
        
        .variant-item:hover {
            background: var(--input-hover-bg);
            border-color: var(--border-color);
            transform: translateX(2px);
        }
        
        .variant-item.active {
            background: var(--accent-primary);
            color: var(--bg-primary);
            border-color: var(--accent-primary);
            font-weight: 600;
            transform: translateX(4px);
        }
        
        .variant-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .variant-gene {
            font-weight: 600;
            font-size: 13px;
        }
        
        .variant-details {
            font-size: 11px;
            opacity: 0.8;
        }
        
        .variant-scores {
            font-size: 10px;
            margin-top: 4px;
            display: flex;
            justify-content: space-between;
        }
        
        /* Main Panel Styles */
        .visualization-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto auto auto auto auto;
            gap: 15px;
            max-height: var(--main-content-height, 600px);
            overflow-y: auto;
            width: 100%;
            max-width: 100%;
        }
        
        .viz-section {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 14px;
            border: 1px solid var(--border-color);
            transition: all 0.2s ease;
            min-width: 0;
            max-width: 100%;
        }
        
        .viz-section:hover {
            border-color: var(--accent-primary);
            box-shadow: 0 2px 8px rgba(0, 212, 255, 0.1);
        }
        
        .viz-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--accent-primary);
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .sequence-display {
            grid-column: 1 / -1;
        }
        
        .score-matrix-section {
            grid-column: 1 / -1;
        }
        
        .performance-section {
            grid-column: 1 / -1;
        }
        
        .sequence-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
            max-width: 100%;
            min-width: 0;
        }
        
        .sequence-scroll-container {
            overflow-x: auto;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-primary);
            max-height: 150px;
            overflow-y: auto;
        }
        
        .sequence-wrapper {
            display: flex;
            flex-direction: column;
            width: max-content;
            min-width: 100%;
            max-width: 100%;
        }
        
        .position-axis {
            font-family: 'Courier New', monospace;
            font-size: 10px;
            color: var(--text-secondary);
            padding: 4px 10px 8px 10px;
            white-space: nowrap;
            border-top: 1px solid var(--border-color);
            margin-top: 4px;
        }
        
        .sequence-section {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .sequence-label {
            font-size: 11px;
            font-weight: 600;
            color: var(--accent-primary);
            text-transform: uppercase;
        }
        
        .sequence-text {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.6;
            white-space: nowrap;
            background: transparent;
            padding: 8px 10px;
            border: none;
            overflow: visible;
        }
        
        .base-A { color: var(--base-a-color); }
        .base-C { color: var(--base-c-color); }
        .base-G { color: var(--base-g-color); }
        .base-T { color: var(--base-t-color); }
        
        .mutation-highlight {
            background: var(--accent-secondary);
            color: var(--bg-primary);
            border-radius: 3px;
            padding: 0 2px;
            box-shadow: 0 0 8px rgba(255, 107, 107, 0.4);
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .nucleotide-highlight {
            background: var(--accent-primary);
            color: var(--bg-primary);
            border-radius: 3px;
            padding: 0 2px;
            box-shadow: 0 0 8px rgba(0, 212, 255, 0.4);
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .matrix-controls {
            margin-bottom: 10px;
        }
        
        .toggle-btn {
            background: var(--input-bg);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-right: 10px;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        
        .toggle-btn:hover {
            border-color: var(--accent-primary);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .toggle-btn.active {
            background: var(--accent-primary);
            color: var(--bg-primary);
        }
        
        .matrix-display {
            overflow-x: auto;
            max-height: 250px; /* Much taller to accommodate larger logo */
        }
        
        .score-matrix-section.dual-mode {
            max-height: 500px; /* Expanded height for dual matrix view - heatmap */
        }
        
        .score-matrix-section.dual-mode.logo-mode {
            max-height: 650px; /* Even taller for dual logo view */
        }
        
        .score-matrix-section.dual-mode .matrix-display {
            max-height: 450px; /* Expanded height for dual matrix container - heatmap */
            overflow-y: auto; /* Allow scrolling if content exceeds */
            overflow-x: visible; /* Allow horizontal overflow for wide logos */
        }
        
        .score-matrix-section.dual-mode.logo-mode .matrix-display {
            max-height: 600px; /* Even taller container for dual logo view */
            overflow-x: auto; /* Allow horizontal scrolling for wide logos */
        }
        
        .score-matrix-section .matrix-display {
            overflow-x: auto; /* Allow horizontal scrolling for wide content */
        }
        
        .dual-matrix-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .matrix-section {
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 12px;
            background: var(--bg-primary);
            overflow-x: auto;
            min-height: 200px;
            width: 100%;
            max-width: 100%;
            min-width: 0;
        }
        
        .matrix-subtitle {
            font-size: 12px;
            font-weight: 600;
            color: var(--accent-primary);
            margin-bottom: 8px;
            text-align: center;
        }
        
        .heatmap-legend {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin-top: 8px;
            gap: 4px;
            font-size: 10px;
        }
        
        .legend-gradient {
            width: 200px;
            height: 10px;
            border-radius: 5px;
            border: 1px solid var(--border-color);
        }
        
        .legend-labels {
            display: flex;
            justify-content: space-between;
            width: 202px;
            color: var(--text-secondary);
        }
        
        .tooltip {
            position: absolute;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 11px;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .chart-container {
            height: var(--chart-height, 160px);
            position: relative;
            width: 100%;
            max-width: 100%;
        }
        
        /* Control Styles */
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .control-btn {
            background: var(--input-bg);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            width: 36px;
            height: 36px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        
        .control-btn:hover {
            background: var(--accent-primary);
            color: var(--bg-primary);
        }
        
        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .step-slider {
            flex: 1;
            height: 4px;
            background: var(--input-bg);
            border-radius: 2px;
            outline: none;
            margin: 0 15px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .step-slider::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent-primary);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .step-slider::-webkit-slider-thumb:hover {
            width: 20px;
            height: 20px;
            box-shadow: 0 0 0 4px rgba(0, 212, 255, 0.2);
        }
        
        .step-info {
            font-size: 12px;
            color: var(--text-secondary);
            min-width: 180px;
        }
        
        .theme-toggle {
            background: var(--input-bg);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            width: 36px;
            height: 36px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            font-size: 16px;
        }
        
        .theme-toggle:hover {
            background: var(--input-hover-bg);
        }
        
        .file-input {
            background: var(--accent-primary);
            color: var(--bg-primary);
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        
        .file-input:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 212, 255, 0.3);
        }
        
        /* Scrollbar Styles */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--input-bg);
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-primary);
            box-shadow: 0 0 0 1px rgba(0, 212, 255, 0.3);
        }
        
        .stats-display {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 5px;
        }
        
        .hidden {
            display: none !important;
        }
        
        .loading {
            text-align: center;
            color: var(--text-secondary);
            padding: 40px;
            font-size: 14px;
        }
        
        .method-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }
        
        .method-tab {
            background: var(--input-bg);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }
        
        .method-tab:hover {
            background: var(--input-hover-bg);
        }
        
        .method-tab.active {
            background: var(--accent-primary);
            color: var(--bg-primary);
            border-color: var(--accent-primary);
        }
        
        .correlation-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 10px;
        }
        
        .correlation-item {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px;
        }
        
        .correlation-label {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }
        
        .correlation-value {
            font-size: 16px;
            font-weight: bold;
            color: var(--accent-primary);
        }
        
        .p-value {
            font-size: 10px;
            color: var(--text-secondary);
            margin-top: 2px;
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .viz-section {
            animation: fadeInUp 0.6s ease-out;
        }
        
        .viz-section:nth-child(1) { animation-delay: 0.1s; }
        .viz-section:nth-child(2) { animation-delay: 0.2s; }
        .viz-section:nth-child(3) { animation-delay: 0.3s; }
        .viz-section:nth-child(4) { animation-delay: 0.4s; }
        .viz-section:nth-child(5) { animation-delay: 0.5s; }
        .viz-section:nth-child(6) { animation-delay: 0.6s; }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>🧬 CAGI5 Variant Effect Prediction Visualizer</h1>
            <div style="margin-left: auto; display: flex; align-items: center; gap: 15px;">
                <button class="theme-toggle" id="themeToggle" title="Toggle Light/Dark Mode">
                    <span id="themeIcon">☀️</span>
                </button>
                <input type="file" id="fileInput" accept=".h5,.hdf5,.json" style="display: none;">
                <button class="file-input" onclick="document.getElementById('fileInput').click()">
                    Load VEP Data
                </button>
            </div>
        </header>
        
        <aside class="sidebar">
            <div class="sidebar-section">
                <div class="sidebar-title">Dataset Overview</div>
                <div id="datasetInfo" class="stats-display">No data loaded</div>
            </div>
            
            <div class="sidebar-section">
                <div class="sidebar-title">Filter & Search</div>
                <input type="text" id="searchInput" placeholder="Search variants..." style="width: 100%; padding: 6px; margin-bottom: 10px; background: var(--input-bg); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 12px;">
                <select id="geneFilter" style="width: 100%; padding: 6px; margin-bottom: 10px; background: var(--input-bg); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 12px;">
                    <option value="">All Genes</option>
                </select>
                <select id="cellLineFilter" style="width: 100%; padding: 6px; background: var(--input-bg); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 12px;">
                    <option value="">All Cell Lines</option>
                </select>
            </div>
            
            <div class="sidebar-section">
                <div class="sidebar-title">Variants</div>
            </div>
            
            <div class="variant-list" id="variantList">
                <div class="loading">Load VEP data file to begin</div>
            </div>
        </aside>
        
        <main class="main-panel">
            <div id="mainContent" class="hidden">
                <div class="visualization-grid">
                    <div class="viz-section sequence-display">
                        <div class="viz-title">
                            Variant Sequences
                            <div class="stats-display" id="sequenceStats"></div>
                        </div>
                        <div class="sequence-container">
                            <div id="sequenceScrollContainer" class="sequence-scroll-container">
                                <div class="sequence-wrapper">
                                    <div class="sequence-section">
                                        <div class="sequence-label">Reference Sequence</div>
                                        <div id="refSequenceText" class="sequence-text"></div>
                                    </div>
                                    <div class="sequence-section">
                                        <div class="sequence-label">Alternative Sequence</div>
                                        <div id="altSequenceText" class="sequence-text"></div>
                                    </div>
                                    <div id="positionAxis" class="position-axis"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="viz-section score-matrix-section">
                        <div class="viz-title">
                            <span id="matrixTitle">Score Matrices</span>
                            <div class="matrix-controls">
                                <button class="toggle-btn active" data-mode="heatmap">Heatmap</button>
                                <button class="toggle-btn" data-mode="logo">Logo</button>
                            </div>
                        </div>
                        <div class="method-tabs" style="display: none;">
                            <!-- Only Score Matrix Method has visualizable matrices -->
                            <button class="method-tab active" data-method="score_matrix">Score Matrix Method</button>
                        </div>
                        <div class="matrix-display">
                            <div id="matrixContainer" class="dual-matrix-container">
                                <div class="matrix-section">
                                    <h4 class="matrix-subtitle">Reference Matrix</h4>
                                    <div id="refMatrixContainer" class="heatmap-container"></div>
                                    <div id="refMatrixLegend" class="heatmap-legend"></div>
                                </div>
                                <div class="matrix-section">
                                    <h4 class="matrix-subtitle">Alternative Matrix</h4>
                                    <div id="altMatrixContainer" class="heatmap-container"></div>
                                    <div id="altMatrixLegend" class="heatmap-legend"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="viz-section performance-section">
                        <div class="viz-title">VEP Performance Metrics</div>
                        <div class="method-tabs">
                            <button class="method-tab active" data-perf-method="cosine">Cosine Method</button>
                            <button class="method-tab" data-perf-method="score_matrix">Score Matrix Method</button>
                        </div>
                        <div id="performanceContent">
                            <div class="correlation-grid" id="correlationGrid">
                                <!-- Performance metrics will be populated here -->
                            </div>
                        </div>
                    </div>
                    
                    <div class="viz-section">
                        <div class="viz-title">Per-Gene Correlations</div>
                        <div class="chart-container">
                            <canvas id="geneCorrelationChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="viz-section">
                        <div class="viz-title">VEP Scores Distribution</div>
                        <div class="chart-container">
                            <canvas id="scoresDistributionChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="viz-section">
                        <div class="viz-title">Overall Pearson R vs Steps</div>
                        <div class="chart-container">
                            <canvas id="overallPearsonChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="viz-section">
                        <div class="viz-title">Per-Gene Pearson R vs Steps</div>
                        <div class="chart-container">
                            <canvas id="geneStepsChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="viz-section">
                        <div class="viz-title">Per-Cell Line Pearson R vs Steps</div>
                        <div class="chart-container">
                            <canvas id="cellLineStepsChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="viz-section">
                        <div class="viz-title">Score Changes vs Steps</div>
                        <div class="chart-container">
                            <canvas id="scoreChangesChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="placeholderContent" class="loading">
                <h2>Welcome to CAGI5 VEP Visualizer</h2>
                <p>Load your variant effect prediction data to begin exploring</p>
                <br>
                <div style="text-align: left; max-width: 600px; margin: 0 auto; font-size: 12px; color: #888;">
                    <p><strong>Supported formats:</strong></p>
                    <ul style="margin-left: 20px;">
                        <li><strong>JSON</strong> - Converted VEP data for browser compatibility</li>
                        <li><strong>HDF5</strong> (.h5, .hdf5) - Native CAGI5 VEP output format</li>
                    </ul>
                    <br>
                    <p><strong>Features:</strong></p>
                    <ul style="margin-left: 20px;">
                        <li>Cosine similarity and score matrix methods</li>
                        <li>Per-gene and per-cell-line performance analysis</li>
                        <li>Noise level impact visualization</li>
                        <li>Reference vs alternative sequence comparison</li>
                        <li>Interactive score matrix exploration</li>
                    </ul>
                </div>
            </div>
        </main>
        
        <div class="controls">
            <div class="control-group">
                <button class="control-btn" id="playBtn" title="Play/Pause">
                    <span id="playIcon">▶</span>
                </button>
                <button class="control-btn" id="prevBtn" title="Previous Step">⏮</button>
                <button class="control-btn" id="nextBtn" title="Next Step">⏭</button>
            </div>
            
            <input type="range" id="stepSlider" class="step-slider" min="0" max="0" value="0">
            
            <div class="step-info">
                <span id="stepInfo">Noise Step: 0 / 0</span>
            </div>
            
            <div class="control-group">
                <label style="font-size: 12px; color: #888;">Speed:</label>
                <input type="range" id="speedSlider" min="1" max="10" value="3" style="width: 80px;">
            </div>
        </div>
    </div>
    
    <!-- Tooltip for heatmap hover -->
    <div id="tooltip" class="tooltip"></div>

    <script>
        class VEPVisualizer {
            constructor() {
                this.data = null;
                this.currentVariant = 0;
                this.currentStep = 0; // For noise step navigation
                this.currentMethod = 'score_matrix'; // Only score matrix method has visualizable matrices
                this.currentPerfMethod = 'cosine';
                this.isPlaying = false;
                this.playInterval = null;
                this.charts = {};
                this.matrixMode = 'heatmap';
                this.theme = 'dark';
                this.filteredVariants = [];
                this.highlightedPosition = null; // Track highlighted nucleotide position
                this.isScrollingSyncronized = false; // Prevent infinite scroll loop
                this.scrollHandlers = null; // Store scroll event handlers for cleanup
                
                this.initializeElements();
                this.setupEventListeners();
                this.initializeCharts();
                this.initializeTheme();
                this.setupViewportSizing();
            }
            
            initializeElements() {
                this.elements = {
                    fileInput: document.getElementById('fileInput'),
                    variantList: document.getElementById('variantList'),
                    datasetInfo: document.getElementById('datasetInfo'),
                    mainContent: document.getElementById('mainContent'),
                    placeholderContent: document.getElementById('placeholderContent'),
                    searchInput: document.getElementById('searchInput'),
                    geneFilter: document.getElementById('geneFilter'),
                    cellLineFilter: document.getElementById('cellLineFilter'),
                    refSequenceText: document.getElementById('refSequenceText'),
                    altSequenceText: document.getElementById('altSequenceText'),
                    sequenceStats: document.getElementById('sequenceStats'),
                    positionAxis: document.getElementById('positionAxis'),
                    matrixTitle: document.getElementById('matrixTitle'),
                    refMatrixContainer: document.getElementById('refMatrixContainer'),
                    altMatrixContainer: document.getElementById('altMatrixContainer'),
                    refMatrixLegend: document.getElementById('refMatrixLegend'),
                    altMatrixLegend: document.getElementById('altMatrixLegend'),
                    correlationGrid: document.getElementById('correlationGrid'),
                    performanceContent: document.getElementById('performanceContent'),
                    stepSlider: document.getElementById('stepSlider'),
                    stepInfo: document.getElementById('stepInfo'),
                    playBtn: document.getElementById('playBtn'),
                    playIcon: document.getElementById('playIcon'),
                    prevBtn: document.getElementById('prevBtn'),
                    nextBtn: document.getElementById('nextBtn'),
                    speedSlider: document.getElementById('speedSlider'),
                    themeToggle: document.getElementById('themeToggle'),
                    themeIcon: document.getElementById('themeIcon')
                };
            }
            
            setupEventListeners() {
                this.elements.fileInput.addEventListener('change', (e) => this.handleFileLoad(e));
                this.elements.searchInput.addEventListener('input', () => this.filterVariants());
                this.elements.geneFilter.addEventListener('change', () => this.filterVariants());
                this.elements.cellLineFilter.addEventListener('change', () => this.filterVariants());
                this.elements.stepSlider.addEventListener('input', (e) => this.setStep(parseInt(e.target.value)));
                this.elements.playBtn.addEventListener('click', () => this.togglePlay());
                this.elements.prevBtn.addEventListener('click', () => this.previousStep());
                this.elements.nextBtn.addEventListener('click', () => this.nextStep());
                this.elements.speedSlider.addEventListener('input', () => this.updatePlaySpeed());
                
                document.querySelectorAll('.toggle-btn[data-mode]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        this.setMatrixMode(e.target.dataset.mode);
                    });
                });
                
                document.querySelectorAll('.method-tab[data-method]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        this.setMethod(e.target.dataset.method);
                    });
                });
                
                document.querySelectorAll('.method-tab[data-perf-method]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        this.setPerfMethod(e.target.dataset.perfMethod);
                    });
                });
                
                this.elements.themeToggle.addEventListener('click', () => this.toggleTheme());
                
                document.addEventListener('keydown', (e) => this.handleKeydown(e));
                window.addEventListener('resize', () => this.handleResize());
            }
            
            handleKeydown(event) {
                if (!this.data) return;
                
                if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.tagName === 'SELECT') return;
                
                switch(event.key) {
                    case 'ArrowUp':
                        event.preventDefault();
                        if (this.currentVariant > 0) {
                            this.selectVariant(this.currentVariant - 1);
                        }
                        break;
                    case 'ArrowDown':
                        event.preventDefault();
                        if (this.currentVariant < this.filteredVariants.length - 1) {
                            this.selectVariant(this.currentVariant + 1);
                        }
                        break;
                    case 'ArrowLeft':
                        event.preventDefault();
                        this.previousStep();
                        break;
                    case 'ArrowRight':
                        event.preventDefault();
                        this.nextStep();
                        break;
                    case ' ':
                        event.preventDefault();
                        this.togglePlay();
                        break;
                }
            }
            
            setupViewportSizing() {
                this.updateViewportSizes();
            }
            
            handleResize() {
                clearTimeout(this.resizeTimeout);
                this.resizeTimeout = setTimeout(() => {
                    this.updateViewportSizes();
                    this.refreshVisualizationSizes();
                }, 150);
            }
            
            updateViewportSizes() {
                const vh = window.innerHeight;
                const headerHeight = 60;
                const controlsHeight = 80;
                const sidebarInfoHeight = 180;
                const padding = 40;
                
                const mainContentHeight = vh - headerHeight - controlsHeight - padding;
                const sidebarContentHeight = vh - sidebarInfoHeight - padding;
                let chartHeight = 160;
                if (vh < 800) chartHeight = 120;
                else if (vh > 1200) chartHeight = 180;
                
                document.documentElement.style.setProperty('--main-content-height', `${mainContentHeight}px`);
                document.documentElement.style.setProperty('--sidebar-content-height', `${sidebarContentHeight}px`);
                document.documentElement.style.setProperty('--chart-height', `${chartHeight}px`);
                
                document.body.offsetHeight;
            }
            
            refreshVisualizationSizes() {
                if (!this.data) return;
                
                if (this.charts) {
                    Object.values(this.charts).forEach(chart => {
                        if (chart.resize) {
                            chart.resize();
                        }
                    });
                }
                
                this.updateVisualization();
            }
            
            initializeTheme() {
                const savedTheme = localStorage.getItem('vep-visualizer-theme');
                let theme = savedTheme;
                
                if (!savedTheme) {
                    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches) {
                        theme = 'light';
                    } else {
                        theme = 'dark';
                    }
                }
                
                this.setTheme(theme);
                
                if (window.matchMedia) {
                    window.matchMedia('(prefers-color-scheme: light)').addEventListener('change', (e) => {
                        if (!localStorage.getItem('vep-visualizer-theme')) {
                            this.setTheme(e.matches ? 'light' : 'dark');
                        }
                    });
                }
            }
            
            toggleTheme() {
                const newTheme = this.theme === 'dark' ? 'light' : 'dark';
                this.setTheme(newTheme);
            }
            
            setTheme(theme) {
                this.theme = theme;
                document.documentElement.setAttribute('data-theme', theme);
                this.elements.themeIcon.textContent = theme === 'dark' ? '☀️' : '🌙';
                localStorage.setItem('vep-visualizer-theme', theme);
                this.updateChartThemes();
            }
            
            updateChartThemes() {
                if (!this.charts || Object.keys(this.charts).length === 0) return;
                
                const chartColors = {
                    dark: { gridColor: '#333', textColor: '#888' },
                    light: { gridColor: '#dee2e6', textColor: '#6c757d' }
                };
                
                const colors = chartColors[this.theme];
                
                Object.values(this.charts).forEach(chart => {
                    if (chart.options?.scales) {
                        ['x', 'y'].forEach(axis => {
                            if (chart.options.scales[axis]?.grid) {
                                chart.options.scales[axis].grid.color = colors.gridColor;
                            }
                            if (chart.options.scales[axis]?.ticks) {
                                chart.options.scales[axis].ticks.color = colors.textColor;
                            }
                        });
                        chart.update('none');
                    }
                });
            }
            
            async handleFileLoad(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                this.elements.variantList.innerHTML = '<div class="loading">Loading VEP data...</div>';
                
                try {
                    const fileExtension = file.name.toLowerCase().split('.').pop();
                    
                    if (fileExtension === 'h5' || fileExtension === 'hdf5') {
                        this.data = await this.loadHDF5File(file);
                    } else if (fileExtension === 'json') {
                        this.data = await this.loadJSONFile(file);
                    } else {
                        throw new Error('Unsupported file format. Please use .h5, .hdf5, or .json files.');
                    }
                    
                    this.initializeVisualization();
                } catch (error) {
                    console.error('Error loading file:', error);
                    alert(`Error loading file: ${error.message}`);
                    this.elements.variantList.innerHTML = '<div class="loading">Load VEP data file to begin</div>';
                }
            }
            
            async loadHDF5File(file) {
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const h5file = await h5wasm.HDF5File.open(arrayBuffer);
                    
                    // Extract VEP data structure based on the H5 format specification
                    const data = {
                        metadata: this.extractMetadata(h5file),
                        input_data: this.extractInputData(h5file),
                        noise_schedule: this.extractNoiseSchedule(h5file),
                        method_cosine_similarity: this.extractCosineMethod(h5file),
                        method_score_matrix: this.extractScoreMatrixMethod(h5file),
                        evaluation_results: this.extractEvaluationResults(h5file)
                    };
                    
                    return data;
                } catch (error) {
                    console.error('Error parsing HDF5 file:', error);
                    throw new Error(`Failed to parse HDF5 file: ${error.message}`);
                }
            }
            
            extractMetadata(h5file) {
                const metadata = {};
                if (h5file.has('metadata')) {
                    const metadataGroup = h5file.get('metadata');
                    
                    // Extract all metadata attributes
                    const keys = ['dataset_info', 'model_checkpoint', 'config_used', 'num_sequences', 
                                 'sequence_length', 'num_noise_steps', 'methods_used', 'genes', 
                                 'cell_lines', 'timestamp'];
                    
                    keys.forEach(key => {
                        if (metadataGroup.has(key)) {
                            const value = metadataGroup.get(key).value;
                            metadata[key] = Array.isArray(value) ? Array.from(value) : value;
                        }
                    });
                }
                return metadata;
            }
            
            extractInputData(h5file) {
                const inputData = {};
                if (h5file.has('input_data')) {
                    const inputGroup = h5file.get('input_data');
                    
                    const keys = ['ref_sequences', 'alt_sequences', 'mutation_positions', 
                                 'ref_nucleotides', 'alt_nucleotides', 'ground_truth_scores',
                                 'genes', 'cell_lines', 'identifiers'];
                    
                    keys.forEach(key => {
                        if (inputGroup.has(key)) {
                            const value = inputGroup.get(key).value;
                            inputData[key] = Array.from(value);
                        }
                    });
                }
                return inputData;
            }
            
            extractNoiseSchedule(h5file) {
                const noiseSchedule = {};
                if (h5file.has('noise_schedule')) {
                    const noiseGroup = h5file.get('noise_schedule');
                    
                    ['sigma_values', 'sigma_indices', 'default_sigma_idx'].forEach(key => {
                        if (noiseGroup.has(key)) {
                            const value = noiseGroup.get(key).value;
                            noiseSchedule[key] = Array.isArray(value) ? Array.from(value) : value;
                        }
                    });
                }
                return noiseSchedule;
            }
            
            extractCosineMethod(h5file) {
                const cosineMethod = {};
                if (h5file.has('method_cosine_similarity')) {
                    const cosineGroup = h5file.get('method_cosine_similarity');
                    
                    // Extract default step data
                    if (cosineGroup.has('default_step')) {
                        const defaultStep = cosineGroup.get('default_step');
                        cosineMethod.default_step = {};
                        
                        ['ref_representations', 'alt_representations', 'cosine_scores', 'noise_level'].forEach(key => {
                            if (defaultStep.has(key)) {
                                const value = defaultStep.get(key).value;
                                cosineMethod.default_step[key] = Array.from(value);
                            }
                        });
                    }
                    
                    // Extract all steps if available
                    if (cosineGroup.has('all_steps')) {
                        cosineMethod.all_steps = this.extractAllSteps(cosineGroup.get('all_steps'));
                    }
                }
                return cosineMethod;
            }
            
            extractScoreMatrixMethod(h5file) {
                const scoreMatrixMethod = {};
                if (h5file.has('method_score_matrix')) {
                    const scoreMatrixGroup = h5file.get('method_score_matrix');
                    
                    // Extract default step data
                    if (scoreMatrixGroup.has('default_step')) {
                        const defaultStep = scoreMatrixGroup.get('default_step');
                        scoreMatrixMethod.default_step = {};
                        
                        ['ref_score_matrices', 'alt_score_matrices', 'ref_mutation_scores', 
                         'alt_mutation_scores', 'score_differences', 'noise_level'].forEach(key => {
                            if (defaultStep.has(key)) {
                                const value = defaultStep.get(key).value;
                                scoreMatrixMethod.default_step[key] = Array.from(value);
                            }
                        });
                    }
                    
                    // Extract all steps if available
                    if (scoreMatrixGroup.has('all_steps')) {
                        scoreMatrixMethod.all_steps = this.extractAllSteps(scoreMatrixGroup.get('all_steps'));
                    }
                }
                return scoreMatrixMethod;
            }
            
            extractAllSteps(stepsGroup) {
                const allSteps = {};
                const stepKeys = Array.from(stepsGroup.keys()).filter(key => key.startsWith('step_'));
                
                stepKeys.forEach(stepKey => {
                    const step = stepsGroup.get(stepKey);
                    allSteps[stepKey] = {};
                    
                    Array.from(step.keys()).forEach(key => {
                        const value = step.get(key).value;
                        allSteps[stepKey][key] = Array.isArray(value) ? Array.from(value) : value;
                    });
                });
                
                return allSteps;
            }
            
            extractEvaluationResults(h5file) {
                const evaluationResults = {};
                if (h5file.has('evaluation_results')) {
                    const evalGroup = h5file.get('evaluation_results');
                    
                    // Extract overall metrics
                    if (evalGroup.has('overall_metrics')) {
                        evaluationResults.overall_metrics = {};
                        const overallGroup = evalGroup.get('overall_metrics');
                        
                        ['cosine_method', 'score_matrix_method'].forEach(method => {
                            if (overallGroup.has(method)) {
                                evaluationResults.overall_metrics[method] = {};
                                const methodGroup = overallGroup.get(method);
                                
                                ['pearson_r', 'p_value', 'k562_pearson_r', 'hepg2_average_pearson_r'].forEach(key => {
                                    if (methodGroup.has(key)) {
                                        const value = methodGroup.get(key).value;
                                        evaluationResults.overall_metrics[method][key] = Array.isArray(value) ? Array.from(value) : value;
                                    }
                                });
                            }
                        });
                    }
                    
                    // Extract per-gene results
                    if (evalGroup.has('per_gene_results')) {
                        evaluationResults.per_gene_results = {};
                        const geneGroup = evalGroup.get('per_gene_results');
                        
                        ['cosine_method', 'score_matrix_method'].forEach(method => {
                            if (geneGroup.has(method)) {
                                evaluationResults.per_gene_results[method] = {};
                                const methodGroup = geneGroup.get(method);
                                
                                ['gene_names', 'pearson_correlations', 'p_values', 'sample_counts'].forEach(key => {
                                    if (methodGroup.has(key)) {
                                        const value = methodGroup.get(key).value;
                                        evaluationResults.per_gene_results[method][key] = Array.from(value);
                                    }
                                });
                            }
                        });
                    }
                    
                    // Extract per-cell-line results
                    if (evalGroup.has('per_cell_line_results')) {
                        evaluationResults.per_cell_line_results = {};
                        const cellLineGroup = evalGroup.get('per_cell_line_results');
                        
                        ['cosine_method', 'score_matrix_method'].forEach(method => {
                            if (cellLineGroup.has(method)) {
                                evaluationResults.per_cell_line_results[method] = {};
                                const methodGroup = cellLineGroup.get(method);
                                
                                ['cell_line_names', 'pearson_correlations', 'p_values', 'sample_counts'].forEach(key => {
                                    if (methodGroup.has(key)) {
                                        const value = methodGroup.get(key).value;
                                        evaluationResults.per_cell_line_results[method][key] = Array.from(value);
                                    }
                                });
                            }
                        });
                    }
                    
                    // Extract all steps metrics if available
                    if (evalGroup.has('all_steps_metrics')) {
                        evaluationResults.all_steps_metrics = this.extractAllStepsMetrics(evalGroup.get('all_steps_metrics'));
                    }
                }
                return evaluationResults;
            }
            
            extractAllStepsMetrics(allStepsGroup) {
                const allStepsMetrics = {};
                
                ['cosine_method', 'score_matrix_method'].forEach(method => {
                    if (allStepsGroup.has(method)) {
                        allStepsMetrics[method] = {};
                        const methodGroup = allStepsGroup.get(method);
                        const stepKeys = Array.from(methodGroup.keys()).filter(key => key.startsWith('step_'));
                        
                        stepKeys.forEach(stepKey => {
                            const step = methodGroup.get(stepKey);
                            allStepsMetrics[method][stepKey] = {};
                            
                            // Extract noise_level
                            if (step.has('noise_level')) {
                                const value = step.get('noise_level').value;
                                allStepsMetrics[method][stepKey].noise_level = Array.isArray(value) ? Array.from(value) : value;
                            }
                            
                            // Extract overall, per_gene, per_cell_line metrics
                            ['overall', 'per_gene', 'per_cell_line'].forEach(category => {
                                if (step.has(category)) {
                                    allStepsMetrics[method][stepKey][category] = {};
                                    const categoryGroup = step.get(category);
                                    
                                    Array.from(categoryGroup.keys()).forEach(key => {
                                        const value = categoryGroup.get(key).value;
                                        allStepsMetrics[method][stepKey][category][key] = Array.isArray(value) ? Array.from(value) : value;
                                    });
                                }
                            });
                        });
                    }
                });
                
                return allStepsMetrics;
            }
            
            async loadJSONFile(file) {
                const text = await file.text();
                const data = JSON.parse(text);
                
                if (!data.metadata || !data.input_data || !data.evaluation_results) {
                    throw new Error('Invalid VEP data format. Expected structure with metadata, input_data, and evaluation_results.');
                }
                
                return data;
            }
            
            initializeVisualization() {
                this.elements.placeholderContent.classList.add('hidden');
                this.elements.mainContent.classList.remove('hidden');
                
                this.updateDatasetInfo();
                this.populateFilters();
                this.createVariantList();
                this.setupNoiseStepSlider();
                this.selectVariant(0);
                this.updateCharts();
            }
            
            updateDatasetInfo() {
                const meta = this.data.metadata;
                this.elements.datasetInfo.innerHTML = `
                    Dataset: ${meta.dataset_info || 'CAGI5 VEP'}<br>
                    Sequences: ${meta.num_sequences}<br>
                    Length: ${meta.sequence_length}<br>
                    Methods: ${meta.methods_used ? meta.methods_used.join(', ') : 'Cosine, Score Matrix'}<br>
                    Genes: ${meta.genes ? meta.genes.length : 'N/A'}<br>
                    Cell Lines: ${meta.cell_lines ? meta.cell_lines.length : 'N/A'}
                `;
            }
            
            populateFilters() {
                // Populate gene filter
                if (this.data.metadata.genes) {
                    this.elements.geneFilter.innerHTML = '<option value="">All Genes</option>';
                    this.data.metadata.genes.forEach(gene => {
                        const option = document.createElement('option');
                        option.value = gene;
                        option.textContent = gene;
                        this.elements.geneFilter.appendChild(option);
                    });
                }
                
                // Populate cell line filter
                if (this.data.metadata.cell_lines) {
                    this.elements.cellLineFilter.innerHTML = '<option value="">All Cell Lines</option>';
                    this.data.metadata.cell_lines.forEach(cellLine => {
                        const option = document.createElement('option');
                        option.value = cellLine;
                        option.textContent = cellLine;
                        this.elements.cellLineFilter.appendChild(option);
                    });
                }
            }
            
            createVariantList() {
                this.filteredVariants = [];
                for (let i = 0; i < this.data.metadata.num_sequences; i++) {
                    this.filteredVariants.push(i);
                }
                this.filterVariants();
            }
            
            filterVariants() {
                if (!this.data) return;
                
                const searchTerm = this.elements.searchInput.value.toLowerCase();
                const geneFilter = this.elements.geneFilter.value;
                const cellLineFilter = this.elements.cellLineFilter.value;
                
                this.filteredVariants = [];
                
                for (let i = 0; i < this.data.metadata.num_sequences; i++) {
                    const gene = this.data.input_data.genes[i];
                    const cellLine = this.data.input_data.cell_lines[i];
                    const identifier = this.data.input_data.identifiers[i];
                    
                    // Apply filters
                    if (geneFilter && gene !== geneFilter) continue;
                    if (cellLineFilter && cellLine !== cellLineFilter) continue;
                    if (searchTerm && !identifier.toLowerCase().includes(searchTerm) && 
                        !gene.toLowerCase().includes(searchTerm)) continue;
                    
                    this.filteredVariants.push(i);
                }
                
                this.renderVariantList();
            }
            
            renderVariantList() {
                this.elements.variantList.innerHTML = '';
                
                this.filteredVariants.forEach((variantIndex, displayIndex) => {
                    const item = document.createElement('div');
                    item.className = 'variant-item';
                    item.addEventListener('click', () => this.selectVariant(displayIndex));
                    
                    const gene = this.data.input_data.genes[variantIndex];
                    const cellLine = this.data.input_data.cell_lines[variantIndex];
                    const identifier = this.data.input_data.identifiers[variantIndex];
                    const mutPos = this.data.input_data.mutation_positions[variantIndex];
                    const refNuc = ['A', 'C', 'G', 'T'][this.data.input_data.ref_nucleotides[variantIndex]];
                    const altNuc = ['A', 'C', 'G', 'T'][this.data.input_data.alt_nucleotides[variantIndex]];
                    const groundTruth = this.data.input_data.ground_truth_scores[variantIndex];
                    
                    // Get VEP scores for both methods
                    const cosineScore = this.data.method_cosine_similarity?.default_step?.cosine_scores[variantIndex] || 'N/A';
                    const scoreMatrixScore = this.data.method_score_matrix?.default_step?.score_differences[variantIndex] || 'N/A';
                    
                    item.innerHTML = `
                        <div class="variant-info">
                            <div class="variant-gene">${gene} (${cellLine})</div>
                            <div class="variant-details">${identifier}</div>
                            <div class="variant-details">Pos ${mutPos + 1}: ${refNuc}>${altNuc}</div>
                            <div class="variant-scores">
                                <span>GT: ${groundTruth.toFixed(3)}</span>
                                <span>Cos: ${typeof cosineScore === 'number' ? cosineScore.toFixed(3) : cosineScore}</span>
                                <span>Mat: ${typeof scoreMatrixScore === 'number' ? scoreMatrixScore.toFixed(3) : scoreMatrixScore}</span>
                            </div>
                        </div>
                    `;
                    
                    this.elements.variantList.appendChild(item);
                });
            }
            
            sortStepKeys(stepKeys) {
                return stepKeys.sort((a, b) => {
                    const aNum = parseInt(a.replace('step_', ''));
                    const bNum = parseInt(b.replace('step_', ''));
                    return aNum - bNum;
                });
            }
            
            getMaxSteps() {
                let maxSteps = 0;
                
                if (this.data?.evaluation_results?.all_steps_metrics) {
                    const methods = ['cosine_method', 'score_matrix_method'];
                    methods.forEach(method => {
                        const allSteps = this.data.evaluation_results.all_steps_metrics[method];
                        if (allSteps) {
                            const stepKeys = this.sortStepKeys(Object.keys(allSteps).filter(key => key.startsWith('step_')));
                            maxSteps = Math.max(maxSteps, stepKeys.length);
                        }
                    });
                }
                
                return maxSteps;
            }
            
            setupNoiseStepSlider() {
                // Check if we have all_steps data for noise step navigation
                let maxSteps = 0;
                
                // Check all possible sources of step data
                if (this.data.method_cosine_similarity?.all_steps) {
                    const stepKeys = this.sortStepKeys(Object.keys(this.data.method_cosine_similarity.all_steps).filter(key => key.startsWith('step_')));
                    maxSteps = Math.max(maxSteps, stepKeys.length - 1);
                }
                
                if (this.data.method_score_matrix?.all_steps) {
                    const stepKeys = this.sortStepKeys(Object.keys(this.data.method_score_matrix.all_steps).filter(key => key.startsWith('step_')));
                    maxSteps = Math.max(maxSteps, stepKeys.length - 1);
                }
                
                if (this.data.evaluation_results?.all_steps_metrics) {
                    const methods = ['cosine_method', 'score_matrix_method'];
                    methods.forEach(method => {
                        const allSteps = this.data.evaluation_results.all_steps_metrics[method];
                        if (allSteps) {
                            const stepKeys = this.sortStepKeys(Object.keys(allSteps).filter(key => key.startsWith('step_')));
                            maxSteps = Math.max(maxSteps, stepKeys.length - 1);
                        }
                    });
                }
                
                if (maxSteps > 0) {
                    // Show controls and set up slider
                    this.elements.stepSlider.max = maxSteps;
                    this.elements.stepSlider.value = 0;
                    this.currentStep = 0;
                    this.elements.stepSlider.style.display = '';
                    this.elements.playBtn.style.display = '';
                    this.elements.prevBtn.style.display = '';
                    this.elements.nextBtn.style.display = '';
                    this.updateStepInfo();
                    console.log(`Noise step navigation enabled: ${maxSteps + 1} steps available`);
                } else {
                    // Hide controls if no step data
                    this.elements.stepSlider.style.display = 'none';
                    this.elements.playBtn.style.display = 'none';
                    this.elements.prevBtn.style.display = 'none';
                    this.elements.nextBtn.style.display = 'none';
                    this.elements.stepInfo.textContent = 'Default noise level';
                    console.log('No step data found - using default noise level only');
                }
            }
            
            selectVariant(displayIndex) {
                this.currentVariant = displayIndex;
                
                // Clear highlight when switching variants (different sequence)
                this.highlightedPosition = null;
                
                // Update active variant in list
                document.querySelectorAll('.variant-item').forEach((item, index) => {
                    item.classList.toggle('active', index === displayIndex);
                });
                
                // Scroll to active variant
                const activeItem = document.querySelector('.variant-item.active');
                if (activeItem) {
                    activeItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
                
                this.updateVisualization();
                this.updatePerformanceMetrics();
            }
            
            updateVisualization() {
                if (!this.data || this.filteredVariants.length === 0) return;
                
                const variantIndex = this.filteredVariants[this.currentVariant];
                this.updateSequenceDisplay(variantIndex);
                this.updateMatrices(variantIndex);
            }
            
            updateSequenceDisplay(variantIndex) {
                const refSeq = this.data.input_data.ref_sequences[variantIndex];
                const altSeq = this.data.input_data.alt_sequences[variantIndex];
                const mutPos = this.data.input_data.mutation_positions[variantIndex];
                
                // Convert sequences to displayable format
                const baseNames = ['A', 'C', 'G', 'T'];
                const baseClasses = ['base-A', 'base-C', 'base-G', 'base-T'];
                
                // Reference sequence - handle both integer and one-hot formats
                let refHtml = '';
                refSeq.forEach((baseData, index) => {
                    let baseIndex;
                    if (Array.isArray(baseData)) {
                        // One-hot encoded
                        baseIndex = baseData.indexOf(1);
                    } else {
                        // Integer encoded
                        baseIndex = baseData;
                    }
                    
                    const isMutation = index === mutPos;
                    const isHighlighted = this.highlightedPosition === index;
                    let highlightClass = '';
                    if (isMutation) highlightClass += ' mutation-highlight';
                    if (isHighlighted) highlightClass += ' nucleotide-highlight';
                    
                    if (baseIndex >= 0 && baseIndex < 4) {
                        refHtml += `<span class="${baseClasses[baseIndex]}${highlightClass}" data-position="${index}" style="cursor: pointer;">${baseNames[baseIndex]}</span>`;
                    } else {
                        refHtml += `<span class="${highlightClass}" data-position="${index}" style="cursor: pointer;">N</span>`;
                    }
                    if ((index + 1) % 10 === 0) refHtml += ' ';
                });
                
                // Alternative sequence - handle both integer and one-hot formats
                let altHtml = '';
                altSeq.forEach((baseData, index) => {
                    let baseIndex;
                    if (Array.isArray(baseData)) {
                        // One-hot encoded
                        baseIndex = baseData.indexOf(1);
                    } else {
                        // Integer encoded
                        baseIndex = baseData;
                    }
                    
                    const isMutation = index === mutPos;
                    const isHighlighted = this.highlightedPosition === index;
                    let highlightClass = '';
                    if (isMutation) highlightClass += ' mutation-highlight';
                    if (isHighlighted) highlightClass += ' nucleotide-highlight';
                    
                    if (baseIndex >= 0 && baseIndex < 4) {
                        altHtml += `<span class="${baseClasses[baseIndex]}${highlightClass}" data-position="${index}" style="cursor: pointer;">${baseNames[baseIndex]}</span>`;
                    } else {
                        altHtml += `<span class="${highlightClass}" data-position="${index}" style="cursor: pointer;">N</span>`;
                    }
                    if ((index + 1) % 10 === 0) altHtml += ' ';
                });
                
                this.elements.refSequenceText.innerHTML = refHtml;
                this.elements.altSequenceText.innerHTML = altHtml;
                
                // Add click event listeners to sequence spans
                this.addSequenceClickHandlers();
                
                // Update position axis
                this.updatePositionAxis(refSeq.length);
                
                // Update stats
                const gene = this.data.input_data.genes[variantIndex];
                const cellLine = this.data.input_data.cell_lines[variantIndex];
                const groundTruth = this.data.input_data.ground_truth_scores[variantIndex];
                
                this.elements.sequenceStats.innerHTML = 
                    `${gene} (${cellLine}) | Position: ${mutPos + 1} | Ground Truth: ${groundTruth.toFixed(4)}`;
            }
            
            addSequenceClickHandlers() {
                // Add click handlers to reference sequence
                const refSpans = this.elements.refSequenceText.querySelectorAll('span[data-position]');
                refSpans.forEach(span => {
                    span.addEventListener('click', (e) => {
                        const position = parseInt(e.target.dataset.position);
                        this.toggleNucleotideHighlight(position);
                    });
                });
                
                // Add click handlers to alternative sequence
                const altSpans = this.elements.altSequenceText.querySelectorAll('span[data-position]');
                altSpans.forEach(span => {
                    span.addEventListener('click', (e) => {
                        const position = parseInt(e.target.dataset.position);
                        this.toggleNucleotideHighlight(position);
                    });
                });
            }
            
            toggleNucleotideHighlight(position) {
                // Toggle highlight: if same position clicked, remove highlight; otherwise, set new position
                if (this.highlightedPosition === position) {
                    this.highlightedPosition = null;
                } else {
                    this.highlightedPosition = position;
                    this.scrollToNucleotide(position);
                }
                
                // Update sequence display to reflect highlight changes
                if (this.data && this.filteredVariants.length > 0) {
                    this.updateSequenceDisplay(this.filteredVariants[this.currentVariant]);
                    // Also update matrices to show position highlight
                    this.updateMatrices(this.filteredVariants[this.currentVariant]);
                }
            }
            
            scrollToNucleotide(position) {
                // Small delay to ensure DOM has been updated after sequence refresh
                setTimeout(() => {
                    const sequenceContainer = this.elements.sequenceScrollContainer;
                    if (!sequenceContainer) return;
                    
                    // Find the highlighted nucleotide span in reference sequence (could also use alt)
                    const highlightedSpan = this.elements.refSequenceText.querySelector(`[data-position="${position}"]`);
                    if (!highlightedSpan) return;
                    
                    // Get the position of the nucleotide relative to the container
                    const containerRect = sequenceContainer.getBoundingClientRect();
                    const spanRect = highlightedSpan.getBoundingClientRect();
                    
                    // Calculate scroll position to center the nucleotide horizontally
                    const containerWidth = sequenceContainer.clientWidth;
                    const currentScrollLeft = sequenceContainer.scrollLeft;
                    const spanLeftRelative = spanRect.left - containerRect.left + currentScrollLeft;
                    const targetScrollLeft = spanLeftRelative - (containerWidth / 2) + (spanRect.width / 2);
                
                    // Smooth scroll to the target position
                    sequenceContainer.scrollTo({
                        left: Math.max(0, targetScrollLeft),
                        behavior: 'smooth'
                    });
                }, 50); // 50ms delay
            }
            
            updatePositionAxis(sequenceLength) {
                if (!this.elements.positionAxis) return;
                
                let html = '';
                for (let i = 0; i < sequenceLength; i++) {
                    if (i % 10 === 0) {
                        const positionStr = i.toString();
                        html += `<span style="display: inline-block; width: 1ch; text-align: center;">${positionStr.charAt(0)}</span>`;
                        
                        for (let j = 1; j < positionStr.length; j++) {
                            if (i + j < sequenceLength) {
                                html += `<span style="display: inline-block; width: 1ch; text-align: center;">${positionStr.charAt(j)}</span>`;
                                i++;
                            }
                        }
                    } else {
                        html += `<span style="display: inline-block; width: 1.285ch;">&nbsp;</span>`;
                    }
                    
                    if ((i + 1) % 10 === 0 && i + 1 < sequenceLength) {
                        html += ' ';
                    }
                }
                
                this.elements.positionAxis.innerHTML = html;
            }
            
            updateMatrices(variantIndex) {
                // Only score matrix method has visualizable matrices
                if (this.data.method_score_matrix) {
                    this.displayScoreMatrixMethod(variantIndex);
                } else {
                    // No matrix data available
                    this.elements.refMatrixContainer.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-secondary);">No score matrix data available</div>';
                    this.elements.altMatrixContainer.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-secondary);">Load VEP data with score matrices</div>';
                    this.elements.refMatrixLegend.innerHTML = '';
                    this.elements.altMatrixLegend.innerHTML = '';
                }
            }
            
            
            displayScoreMatrixMethod(variantIndex) {
                // Get matrix data for current step
                let refMatrix, altMatrix;
                
                // Check if we have all_steps data and are viewing a specific step
                if (this.data.method_score_matrix.all_steps && this.currentStep > 0) {
                    const stepKeys = this.sortStepKeys(Object.keys(this.data.method_score_matrix.all_steps).filter(key => key.startsWith('step_')));
                    if (this.currentStep < stepKeys.length) {
                        const stepKey = stepKeys[this.currentStep];
                        const stepData = this.data.method_score_matrix.all_steps[stepKey];
                        refMatrix = stepData.ref_score_matrices[variantIndex];
                        altMatrix = stepData.alt_score_matrices[variantIndex];
                    }
                }
                
                // Fallback to default step if no all_steps data or step 0
                if (!refMatrix || !altMatrix) {
                    if (this.data.method_score_matrix.default_step) {
                        refMatrix = this.data.method_score_matrix.default_step.ref_score_matrices[variantIndex];
                        altMatrix = this.data.method_score_matrix.default_step.alt_score_matrices[variantIndex];
                    }
                }
                
                if (!refMatrix || !altMatrix) {
                    this.elements.refMatrixContainer.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-secondary);">No matrix data for this step</div>';
                    this.elements.altMatrixContainer.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-secondary);">No matrix data for this step</div>';
                    return;
                }
                
                // Update CSS classes for proper height handling
                const matrixSection = document.querySelector('.score-matrix-section');
                matrixSection.classList.add('dual-mode');
                if (this.matrixMode === 'logo') {
                    matrixSection.classList.add('logo-mode');
                } else {
                    matrixSection.classList.remove('logo-mode');
                }
                
                if (this.matrixMode === 'heatmap') {
                    this.updateHeatmapInContainer(refMatrix, 'ref', this.elements.refMatrixContainer, this.elements.refMatrixLegend);
                    this.updateHeatmapInContainer(altMatrix, 'alt', this.elements.altMatrixContainer, this.elements.altMatrixLegend);
                    
                    // Set up synchronized scrolling for heatmaps
                    this.setupSynchronizedScrolling(this.elements.refMatrixContainer.parentElement, 
                        this.elements.altMatrixContainer.parentElement);
                } else {
                    this.updateLogoInContainer(refMatrix, 'ref', this.elements.refMatrixContainer);
                    this.updateLogoInContainer(altMatrix, 'alt', this.elements.altMatrixContainer);
                    // Clear legends for logo mode
                    this.elements.refMatrixLegend.innerHTML = '';
                    this.elements.altMatrixLegend.innerHTML = '';
                    
                    // Set up synchronized scrolling for logos
                    this.setupSynchronizedScrolling(this.elements.refMatrixContainer.parentElement, 
                        this.elements.altMatrixContainer.parentElement);
                }
            }
            
            setupSynchronizedScrolling(container1, container2) {
                // Remove any existing scroll listeners to avoid duplicates
                this.removeSynchronizedScrolling();
                
                // Create scroll synchronization handlers
                const syncScroll1 = (event) => {
                    if (!this.isScrollingSyncronized) {
                        this.isScrollingSyncronized = true;
                        container2.scrollLeft = container1.scrollLeft;
                        setTimeout(() => { this.isScrollingSyncronized = false; }, 10);
                    }
                };
                
                const syncScroll2 = (event) => {
                    if (!this.isScrollingSyncronized) {
                        this.isScrollingSyncronized = true;
                        container1.scrollLeft = container2.scrollLeft;
                        setTimeout(() => { this.isScrollingSyncronized = false; }, 10);
                    }
                };
                
                // Add scroll listeners
                container1.addEventListener('scroll', syncScroll1);
                container2.addEventListener('scroll', syncScroll2);
                
                // Store references for cleanup
                this.scrollHandlers = [
                    { element: container1, handler: syncScroll1 },
                    { element: container2, handler: syncScroll2 }
                ];
            }
            
            removeSynchronizedScrolling() {
                if (this.scrollHandlers) {
                    this.scrollHandlers.forEach(({ element, handler }) => {
                        element.removeEventListener('scroll', handler);
                    });
                    this.scrollHandlers = null;
                }
            }
            
            updateHeatmapInContainer(matrix, matrixType, container, legendContainer) {
                container.innerHTML = '';
                
                const cellSize = 12;
                const baseLabels = ['A', 'C', 'G', 'T'];
                
                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', matrix.length * cellSize + 40)
                    .attr('height', 4 * cellSize + 40);
                
                // Create color scale
                const colorScale = d3.scaleSequential(d3.interpolateRdBu)
                    .domain([2, 0]);
                
                const tooltip = d3.select('#tooltip');
                
                // Add base labels
                svg.selectAll('.base-label')
                    .data(baseLabels)
                    .enter()
                    .append('text')
                    .attr('class', 'base-label')
                    .attr('x', 15)
                    .attr('y', (d, i) => 25 + i * cellSize)
                    .attr('text-anchor', 'middle')
                    .attr('dominant-baseline', 'central')
                    .style('fill', this.theme === 'dark' ? '#888' : '#6c757d')
                    .style('font-size', '10px')
                    .text(d => d);
                
                // Add cells
                matrix.forEach((position, posIndex) => {
                    position.forEach((value, baseIndex) => {
                        const rect = svg.append('rect')
                            .attr('x', 30 + posIndex * cellSize)
                            .attr('y', 15 + baseIndex * cellSize)
                            .attr('width', cellSize - 1)
                            .attr('height', cellSize - 1)
                            .style('fill', colorScale(value))
                            .style('cursor', 'pointer')
                            .attr('data-position', posIndex)
                            .attr('data-base', baseIndex);
                            
                        // Add highlight border if this position is highlighted
                        if (this.highlightedPosition === posIndex) {
                            rect.style('stroke', '#00d4ff')
                                .style('stroke-width', '2px')
                                .style('stroke-dasharray', '2,2');
                        }
                        
                        rect.on('mouseover', (event) => {
                                tooltip
                                    .style('opacity', 1)
                                    .html(`Position: ${posIndex + 1}<br/>Base: ${baseLabels[baseIndex]}<br/>Score: ${value.toFixed(4)}`)
                                    .style('left', (event.pageX + 10) + 'px')
                                    .style('top', (event.pageY - 10) + 'px');
                            })
                            .on('mouseout', function() {
                                tooltip.style('opacity', 0);
                            })
                            .on('click', (event) => {
                                event.stopPropagation();
                                this.toggleNucleotideHighlight(posIndex);
                            });
                    });
                });
                
                // Create legend
                if (legendContainer) {
                    this.createMatrixLegend(legendContainer, colorScale, 'Score', matrixType);
                }
            }
            
            updateLogoInContainer(matrix, matrixType, container) {
                container.innerHTML = '';
                
                // Process matrix for logojs
                let processedMatrix = [];
                try {
                    processedMatrix = matrix.map(position => {
                        const cleanPosition = position.map(val => Math.max(0, val || 0));
                        const total = cleanPosition.reduce((a, b) => a + b, 0);
                        
                        return total > 0 ? cleanPosition.map(val => val / total) : [0.25, 0.25, 0.25, 0.25];
                    });
                } catch (error) {
                    console.error('Error processing matrix for logo:', error);
                    container.innerHTML = this.createFallbackLogo(matrix);
                    return;
                }
                
                const logoDiv = document.createElement('div');
                logoDiv.id = `logo-${matrixType}-${Date.now()}`;
                container.appendChild(logoDiv);
                
                const themeColors = this.getThemeBasesColors();
                const customAlphabet = [
                    {regex: 'A', color: themeColors.A, component: logojs?.A},
                    {regex: 'C', color: themeColors.C, component: logojs?.C}, 
                    {regex: 'G', color: themeColors.G, component: logojs?.G},
                    {regex: 'T', color: themeColors.T, component: logojs?.T}
                ];
                
                const logoWidth = processedMatrix.length * 20 + 100;
                const logoConfig = {
                    ppm: processedMatrix,
                    alphabet: customAlphabet,
                    width: logoWidth,
                    height: 200,
                    mode: 'INFORMATION_CONTENT',
                    style: {
                        textColor: this.theme === 'dark' ? '#ffffff' : '#6c757d',
                        axisColor: this.theme === 'dark' ? '#ffffff' : '#6c757d'
                    }
                };
                
                if (typeof logojs !== 'undefined') {
                    try {
                        if (logojs.embedLogo) {
                            logojs.embedLogo(logoDiv, logoConfig);
                        } else if (logojs.embedDNALogo) {
                            logojs.embedDNALogo(logoDiv, logoConfig);
                        } else {
                            container.innerHTML = this.createFallbackLogo(matrix);
                        }
                    } catch (error) {
                        console.error('Error creating logo:', error);
                        container.innerHTML = this.createFallbackLogo(matrix);
                    }
                } else {
                    container.innerHTML = this.createFallbackLogo(matrix);
                }
            }
            
            getThemeBasesColors() {
                const style = getComputedStyle(document.documentElement);
                return {
                    A: style.getPropertyValue('--base-a-color').trim(),
                    C: style.getPropertyValue('--base-c-color').trim(),
                    G: style.getPropertyValue('--base-g-color').trim(),
                    T: style.getPropertyValue('--base-t-color').trim()
                };
            }
            
            createFallbackLogo(matrix) {
                const baseLetters = ['A', 'C', 'G', 'T'];
                const themeColors = this.getThemeBasesColors();
                const baseColors = [themeColors.A, themeColors.C, themeColors.G, themeColors.T];
                
                let html = '<div style="font-family: monospace; font-size: 14px; text-align: center; padding: 20px; color: #888;">';
                html += '<div style="margin-bottom: 10px;">Sequence Logo (Fallback)</div>';
                html += '<div style="display: flex; gap: 2px; justify-content: center; flex-wrap: wrap; max-width: 100%; overflow-x: auto;">';
                
                for (let i = 0; i < Math.min(matrix.length, 60); i++) {
                    const position = matrix[i];
                    
                    if (!Array.isArray(position) || position.length !== 4) {
                        html += '<span style="color: #666;">?</span>';
                        continue;
                    }
                    
                    const cleanPosition = position.map(val => Math.max(0, val || 0));
                    const total = cleanPosition.reduce((a, b) => a + b, 0);
                    
                    if (total > 0) {
                        const normalized = cleanPosition.map(val => val / total);
                        let maxIdx = 0;
                        let maxVal = normalized[0];
                        for (let j = 1; j < normalized.length; j++) {
                            if (normalized[j] > maxVal) {
                                maxVal = normalized[j];
                                maxIdx = j;
                            }
                        }
                        
                        const confidence = maxVal;
                        const opacity = Math.max(0.3, confidence);
                        const fontSize = Math.max(10, 14 * confidence);
                        
                        html += `<span style="color: ${baseColors[maxIdx]}; opacity: ${opacity}; font-weight: bold; font-size: ${fontSize}px;">${baseLetters[maxIdx]}</span>`;
                    } else {
                        html += '<span style="color: #666;">N</span>';
                    }
                }
                
                html += '</div></div>';
                return html;
            }
            
            createMatrixLegend(container, colorScale, valueLabel, matrixType) {
                container.innerHTML = `
                    <div class="legend-labels">
                        <span>Low</span>
                        <span>${valueLabel}</span>
                        <span>High</span>
                    </div>
                    <div class="legend-gradient"></div>
                `;
                
                const uniqueId = `gradient-${matrixType}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                
                const gradientSvg = d3.select(container)
                    .select('.legend-gradient')
                    .append('svg')
                    .attr('width', '100%')
                    .attr('height', '100%');
                
                const gradient = gradientSvg.append('defs')
                    .append('linearGradient')
                    .attr('id', uniqueId)
                    .attr('x1', '0%')
                    .attr('x2', '100%');
                
                const stops = 20;
                for (let i = 0; i <= stops; i++) {
                    const t = i / stops;
                    const colorValue = colorScale(2*t);
                    gradient.append('stop')
                        .attr('offset', `${t * 100}%`)
                        .attr('stop-color', colorValue);
                }
                
                gradientSvg.append('rect')
                    .attr('width', '100%')
                    .attr('height', '100%')
                    .style('fill', `url(#${uniqueId})`);
            }
            
            updatePerformanceMetrics() {
                if (!this.data.evaluation_results) return;
                
                const method = this.currentPerfMethod === 'cosine' ? 'cosine_method' : 'score_matrix_method';
                
                // Check if we have step-specific metrics and use them if available
                let overallMetrics, geneMetrics, cellLineMetrics;
                
                if (this.data.evaluation_results.all_steps_metrics && this.data.evaluation_results.all_steps_metrics[method]) {
                    const allSteps = this.data.evaluation_results.all_steps_metrics[method];
                    const stepKeys = this.sortStepKeys(Object.keys(allSteps).filter(key => key.startsWith('step_')));
                    
                    if (stepKeys.length > 0 && this.currentStep < stepKeys.length) {
                        const currentStepKey = stepKeys[this.currentStep];
                        const stepData = allSteps[currentStepKey];
                        
                        // Use step-specific data
                        overallMetrics = stepData.overall;
                        geneMetrics = stepData.per_gene;
                        cellLineMetrics = stepData.per_cell_line;
                    }
                }
                
                // Fallback to default metrics if no step-specific data
                if (!overallMetrics) {
                    overallMetrics = this.data.evaluation_results.overall_metrics?.[method];
                    geneMetrics = this.data.evaluation_results.per_gene_results?.[method];
                    cellLineMetrics = this.data.evaluation_results.per_cell_line_results?.[method];
                }
                
                let html = '';
                
                // Overall performance
                if (overallMetrics) {
                    html += '<div class="correlation-item">';
                    html += '<div class="correlation-label">Overall Performance</div>';
                    html += `<div class="correlation-value">r = ${overallMetrics.pearson_r?.toFixed(4) || 'N/A'}</div>`;
                    html += `<div class="p-value">p = ${overallMetrics.p_value?.toExponential(2) || 'N/A'}</div>`;
                    html += '</div>';
                    
                    if (overallMetrics.k562_pearson_r !== undefined) {
                        html += '<div class="correlation-item">';
                        html += '<div class="correlation-label">K562 Performance</div>';
                        html += `<div class="correlation-value">r = ${overallMetrics.k562_pearson_r.toFixed(4)}</div>`;
                        html += '</div>';
                    }
                    
                    if (overallMetrics.hepg2_average_pearson_r !== undefined) {
                        html += '<div class="correlation-item">';
                        html += '<div class="correlation-label">HepG2 Average</div>';
                        html += `<div class="correlation-value">r = ${overallMetrics.hepg2_average_pearson_r.toFixed(4)}</div>`;
                        html += '</div>';
                    }
                }
                
                // Per-gene performance
                if (geneMetrics && geneMetrics.gene_names) {
                    geneMetrics.gene_names.forEach((gene, index) => {
                        html += '<div class="correlation-item">';
                        html += `<div class="correlation-label">${gene} Gene</div>`;
                        html += `<div class="correlation-value">r = ${geneMetrics.pearson_correlations[index]?.toFixed(4) || 'N/A'}</div>`;
                        html += `<div class="p-value">p = ${geneMetrics.p_values[index]?.toExponential(2) || 'N/A'}</div>`;
                        html += `<div class="p-value">n = ${geneMetrics.sample_counts[index] || 'N/A'}</div>`;
                        html += '</div>';
                    });
                }
                
                // Per-cell-line performance
                if (cellLineMetrics && cellLineMetrics.cell_line_names) {
                    cellLineMetrics.cell_line_names.forEach((cellLine, index) => {
                        html += '<div class="correlation-item">';
                        html += `<div class="correlation-label">${cellLine} Cell Line</div>`;
                        html += `<div class="correlation-value">r = ${cellLineMetrics.pearson_correlations[index]?.toFixed(4) || 'N/A'}</div>`;
                        html += `<div class="p-value">p = ${cellLineMetrics.p_values[index]?.toExponential(2) || 'N/A'}</div>`;
                        html += `<div class="p-value">n = ${cellLineMetrics.sample_counts[index] || 'N/A'}</div>`;
                        html += '</div>';
                    });
                }
                
                this.elements.correlationGrid.innerHTML = html;
            }
            
            setMethod(method) {
                this.currentMethod = method;
                
                document.querySelectorAll('.method-tab[data-method]').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.method === method);
                });
                
                if (this.data && this.filteredVariants.length > 0) {
                    this.updateMatrices(this.filteredVariants[this.currentVariant]);
                }
            }
            
            setPerfMethod(method) {
                this.currentPerfMethod = method;
                
                document.querySelectorAll('.method-tab[data-perf-method]').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.perfMethod === method);
                });
                
                this.updatePerformanceMetrics();
                this.updateCharts();
            }
            
            setMatrixMode(mode) {
                this.matrixMode = mode;
                
                document.querySelectorAll('.toggle-btn[data-mode]').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === mode);
                });
                
                if (this.data && this.filteredVariants.length > 0) {
                    this.updateMatrices(this.filteredVariants[this.currentVariant]);
                }
            }
            
            initializeCharts() {
                const getChartOptions = () => ({
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { 
                            grid: { color: this.theme === 'dark' ? '#333' : '#dee2e6' },
                            ticks: { color: this.theme === 'dark' ? '#888' : '#6c757d' }
                        },
                        y: { 
                            grid: { color: this.theme === 'dark' ? '#333' : '#dee2e6' },
                            ticks: { color: this.theme === 'dark' ? '#888' : '#6c757d' }
                        }
                    },
                    plugins: {
                        legend: { display: false }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    onClick: (event, elements, chart) => {
                        if (elements.length > 0) {
                            // Get the x-axis value (step) from the clicked point
                            const dataIndex = elements[0].index;
                            if (dataIndex !== undefined && dataIndex >= 0) {
                                this.setStep(dataIndex);
                            }
                        } else {
                            // If no elements are clicked, try to get the step from the x-axis position
                            const canvasPosition = Chart.helpers.getRelativePosition(event, chart);
                            const dataX = chart.scales.x.getValueForPixel(canvasPosition.x);
                            if (dataX !== undefined && dataX >= 0) {
                                const step = Math.round(dataX);
                                const maxSteps = this.getMaxSteps();
                                if (step >= 0 && step < maxSteps) {
                                    this.setStep(step);
                                }
                            }
                        }
                    },
                    onHover: (event, elements, chart) => {
                        chart.canvas.style.cursor = elements.length > 0 ? 'pointer' : 'default';
                    }
                });
                
                // Per-gene correlations chart
                this.charts.geneCorrelation = new Chart(document.getElementById('geneCorrelationChart'), {
                    type: 'bar',
                    data: { datasets: [] },
                    options: getChartOptions()
                });
                
                // Scores distribution chart
                this.charts.scoresDistribution = new Chart(document.getElementById('scoresDistributionChart'), {
                    type: 'scatter',
                    data: { datasets: [] },
                    options: getChartOptions()
                });
                
                // Overall Pearson R vs Steps chart
                this.charts.overallPearson = new Chart(document.getElementById('overallPearsonChart'), {
                    type: 'line',
                    data: { datasets: [] },
                    options: getChartOptions()
                });
                
                // Per-gene Pearson R vs Steps chart
                this.charts.geneSteps = new Chart(document.getElementById('geneStepsChart'), {
                    type: 'line',
                    data: { datasets: [] },
                    options: getChartOptions()
                });
                
                // Per-cell line Pearson R vs Steps chart
                this.charts.cellLineSteps = new Chart(document.getElementById('cellLineStepsChart'), {
                    type: 'line',
                    data: { datasets: [] },
                    options: getChartOptions()
                });
                
                // Score changes vs Steps chart
                this.charts.scoreChanges = new Chart(document.getElementById('scoreChangesChart'), {
                    type: 'line',
                    data: { datasets: [] },
                    options: getChartOptions()
                });
            }
            
            updateCharts() {
                if (!this.data) return;
                
                this.updateGeneCorrelationChart();
                this.updateScoresDistributionChart();
                this.updateOverallPearsonChart();
                this.updateGeneStepsChart();
                this.updateCellLineStepsChart();
                this.updateScoreChangesChart();
            }
            
            
            updateGeneCorrelationChart() {
                const method = this.currentPerfMethod === 'cosine' ? 'cosine_method' : 'score_matrix_method';
                const geneMetrics = this.data.evaluation_results?.per_gene_results?.[method];
                
                if (!geneMetrics || !geneMetrics.gene_names) return;
                
                this.charts.geneCorrelation.data = {
                    labels: geneMetrics.gene_names,
                    datasets: [{
                        data: geneMetrics.pearson_correlations,
                        backgroundColor: ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4'].slice(0, geneMetrics.gene_names.length),
                        borderWidth: 1,
                        borderColor: this.theme === 'dark' ? '#333' : '#dee2e6'
                    }]
                };
                
                this.charts.geneCorrelation.update('none');
            }
            
            updateScoresDistributionChart() {
                // Plot ground truth vs predicted scores
                const method = this.currentPerfMethod === 'cosine' ? 'cosine_method' : 'score_matrix_method';
                let predictedScores;
                
                if (method === 'cosine_method' && this.data.method_cosine_similarity?.default_step) {
                    predictedScores = this.data.method_cosine_similarity.default_step.cosine_scores;
                } else if (method === 'score_matrix_method' && this.data.method_score_matrix?.default_step) {
                    predictedScores = this.data.method_score_matrix.default_step.score_differences;
                }
                
                if (!predictedScores || !this.data.input_data.ground_truth_scores) return;
                
                const scatterData = this.data.input_data.ground_truth_scores.map((gt, i) => ({
                    x: gt,
                    y: predictedScores[i] || 0
                }));
                
                this.charts.scoresDistribution.data = {
                    datasets: [{
                        data: scatterData,
                        backgroundColor: 'rgba(0, 212, 255, 0.6)',
                        borderColor: '#00d4ff',
                        pointRadius: 3,
                        pointHoverRadius: 5
                    }]
                };
                
                this.charts.scoresDistribution.options.scales.x.title = {
                    display: true,
                    text: 'Ground Truth Score'
                };
                this.charts.scoresDistribution.options.scales.y.title = {
                    display: true,
                    text: 'Predicted Score'
                };
                
                this.charts.scoresDistribution.update('none');
            }
            
            updateOverallPearsonChart() {
                const allStepsMetrics = this.data.evaluation_results?.all_steps_metrics;
                if (!allStepsMetrics) return;
                
                const method = this.currentPerfMethod === 'cosine' ? 'cosine_method' : 'score_matrix_method';
                const methodData = allStepsMetrics[method];
                if (!methodData) return;
                
                const stepKeys = this.sortStepKeys(Object.keys(methodData).filter(key => key.startsWith('step_')));
                
                const stepLabels = [];
                const pearsonData = [];
                
                stepKeys.forEach((stepKey, index) => {
                    const stepData = methodData[stepKey];
                    if (stepData.overall?.pearson_r !== undefined) {
                        stepLabels.push(index);
                        pearsonData.push(stepData.overall.pearson_r);
                    }
                });
                
                this.charts.overallPearson.data = {
                    labels: stepLabels,
                    datasets: [{
                        data: pearsonData,
                        borderColor: '#00d4ff',
                        backgroundColor: 'rgba(0, 212, 255, 0.1)',
                        pointRadius: 0,
                        pointHoverRadius: 4,
                        showLine: true,
                        tension: 0.4,
                        fill: false
                    }]
                };
                
                this.charts.overallPearson.options.scales.x.title = {
                    display: true,
                    text: 'Step'
                };
                this.charts.overallPearson.options.scales.y.title = {
                    display: true,
                    text: 'Pearson R'
                };
                this.charts.overallPearson.options.scales.y.min = -1;
                this.charts.overallPearson.options.scales.y.max = 1;
                
                this.charts.overallPearson.update('none');
            }
            
            updateGeneStepsChart() {
                const allStepsMetrics = this.data.evaluation_results?.all_steps_metrics;
                if (!allStepsMetrics) return;
                
                const method = this.currentPerfMethod === 'cosine' ? 'cosine_method' : 'score_matrix_method';
                const methodData = allStepsMetrics[method];
                if (!methodData) return;
                
                const stepKeys = this.sortStepKeys(Object.keys(methodData).filter(key => key.startsWith('step_')));
                const stepLabels = stepKeys.map((_, index) => index);
                
                // Get gene names from the first step
                const firstStepData = methodData[stepKeys[0]];
                if (!firstStepData.per_gene?.gene_names) return;
                
                const geneNames = firstStepData.per_gene.gene_names;
                const datasets = [];
                const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffa726', '#ab47bc'];
                
                geneNames.forEach((geneName, geneIndex) => {
                    const geneData = [];
                    
                    stepKeys.forEach((stepKey, stepIndex) => {
                        const stepData = methodData[stepKey];
                        if (stepData.per_gene?.pearson_correlations?.[geneIndex] !== undefined) {
                            geneData.push(stepData.per_gene.pearson_correlations[geneIndex]);
                        } else {
                            geneData.push(null);
                        }
                    });
                    
                    datasets.push({
                        label: geneName,
                        data: geneData,
                        borderColor: colors[geneIndex % colors.length],
                        backgroundColor: colors[geneIndex % colors.length] + '20',
                        pointRadius: 0,
                        pointHoverRadius: 4,
                        showLine: true,
                        tension: 0.4,
                        fill: false
                    });
                });
                
                this.charts.geneSteps.data = {
                    labels: stepLabels,
                    datasets: datasets
                };
                
                this.charts.geneSteps.options.plugins.legend.display = true;
                this.charts.geneSteps.options.plugins.legend.labels = {
                    color: this.theme === 'dark' ? '#888' : '#6c757d',
                    usePointStyle: true,
                    pointStyle: 'rect',
                    boxWidth: 8,
                    boxHeight: 8,
                    padding: 15
                };
                this.charts.geneSteps.options.scales.x.title = {
                    display: true,
                    text: 'Step'
                };
                this.charts.geneSteps.options.scales.y.title = {
                    display: true,
                    text: 'Pearson R'
                };
                this.charts.geneSteps.options.scales.y.min = -1;
                this.charts.geneSteps.options.scales.y.max = 1;
                
                this.charts.geneSteps.update('none');
            }
            
            updateCellLineStepsChart() {
                const allStepsMetrics = this.data.evaluation_results?.all_steps_metrics;
                if (!allStepsMetrics) return;
                
                const method = this.currentPerfMethod === 'cosine' ? 'cosine_method' : 'score_matrix_method';
                const methodData = allStepsMetrics[method];
                if (!methodData) return;
                
                const stepKeys = this.sortStepKeys(Object.keys(methodData).filter(key => key.startsWith('step_')));
                const stepLabels = stepKeys.map((_, index) => index);
                
                // Get cell line names from the first step
                const firstStepData = methodData[stepKeys[0]];
                if (!firstStepData.per_cell_line?.cell_line_names) return;
                
                const cellLineNames = firstStepData.per_cell_line.cell_line_names;
                const datasets = [];
                const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffa726', '#ab47bc'];
                
                cellLineNames.forEach((cellLineName, cellLineIndex) => {
                    const cellLineData = [];
                    
                    stepKeys.forEach((stepKey, stepIndex) => {
                        const stepData = methodData[stepKey];
                        if (stepData.per_cell_line?.pearson_correlations?.[cellLineIndex] !== undefined) {
                            cellLineData.push(stepData.per_cell_line.pearson_correlations[cellLineIndex]);
                        } else {
                            cellLineData.push(null);
                        }
                    });
                    
                    datasets.push({
                        label: cellLineName,
                        data: cellLineData,
                        borderColor: colors[cellLineIndex % colors.length],
                        backgroundColor: colors[cellLineIndex % colors.length] + '20',
                        pointRadius: 0,
                        pointHoverRadius: 4,
                        showLine: true,
                        tension: 0.4,
                        fill: false
                    });
                });
                
                this.charts.cellLineSteps.data = {
                    labels: stepLabels,
                    datasets: datasets
                };
                
                this.charts.cellLineSteps.options.plugins.legend.display = true;
                this.charts.cellLineSteps.options.plugins.legend.labels = {
                    color: this.theme === 'dark' ? '#888' : '#6c757d',
                    usePointStyle: true,
                    pointStyle: 'rect',
                    boxWidth: 8,
                    boxHeight: 8,
                    padding: 15
                };
                this.charts.cellLineSteps.options.scales.x.title = {
                    display: true,
                    text: 'Step'
                };
                this.charts.cellLineSteps.options.scales.y.title = {
                    display: true,
                    text: 'Pearson R'
                };
                this.charts.cellLineSteps.options.scales.y.min = -1;
                this.charts.cellLineSteps.options.scales.y.max = 1;
                
                this.charts.cellLineSteps.update('none');
            }
            
            updateScoreChangesChart() {
                // Calculate average score changes vs steps - like index.html
                if (!this.data.method_score_matrix?.all_steps) return;
                
                const allStepsData = this.data.method_score_matrix.all_steps;
                const stepKeys = this.sortStepKeys(Object.keys(allStepsData).filter(key => key.startsWith('step_')));
                const stepLabels = stepKeys.map((_, index) => index);
                
                // Need at least 2 steps to calculate changes
                if (stepKeys.length < 2) return;
                
                const scoreChangesData = [];
                const variantIndex = this.filteredVariants[this.currentVariant] || 0;
                
                // First step has no previous step to compare to, so 0 change
                scoreChangesData.push(0);
                
                // Calculate score changes for each subsequent step
                for (let stepIndex = 1; stepIndex < stepKeys.length; stepIndex++) {
                    const currentStepKey = stepKeys[stepIndex];
                    const previousStepKey = stepKeys[stepIndex - 1];
                    
                    const currentStepData = allStepsData[currentStepKey];
                    const previousStepData = allStepsData[previousStepKey];
                    
                    if (!currentStepData.ref_score_matrices || !previousStepData.ref_score_matrices ||
                        !currentStepData.ref_score_matrices[variantIndex] || !previousStepData.ref_score_matrices[variantIndex]) {
                        scoreChangesData.push(null);
                        continue;
                    }
                    
                    const currentMatrix = currentStepData.ref_score_matrices[variantIndex];
                    const previousMatrix = previousStepData.ref_score_matrices[variantIndex];
                    
                    let totalChange = 0;
                    let positionCount = 0;
                    
                    // Compare each base pair position
                    for (let i = 0; i < Math.min(currentMatrix.length, previousMatrix.length); i++) {
                        // Get raw scores for this position
                        const currentRaw = [
                            currentMatrix[i][0] || 0,
                            currentMatrix[i][1] || 0,
                            currentMatrix[i][2] || 0,
                            currentMatrix[i][3] || 0
                        ];
                        const previousRaw = [
                            previousMatrix[i][0] || 0,
                            previousMatrix[i][1] || 0,
                            previousMatrix[i][2] || 0,
                            previousMatrix[i][3] || 0
                        ];
                        
                        // NORMALIZE: Convert to probabilities (sum = 1) for each position
                        const currentSum = currentRaw.reduce((a, b) => a + Math.max(0, b), 0);
                        const previousSum = previousRaw.reduce((a, b) => a + Math.max(0, b), 0);
                        
                        const currentNorm = currentSum > 0 ? 
                            currentRaw.map(val => Math.max(0, val) / currentSum) : 
                            [0.25, 0.25, 0.25, 0.25]; // Equal if sum is 0
                        const previousNorm = previousSum > 0 ? 
                            previousRaw.map(val => Math.max(0, val) / previousSum) : 
                            [0.25, 0.25, 0.25, 0.25]; // Equal if sum is 0
                        
                        // Calculate position change using normalized values
                        let positionChange = 0;
                        for (let j = 0; j < 4; j++) {
                            positionChange += Math.abs(currentNorm[j] - previousNorm[j]);
                        }
                        
                        totalChange += positionChange;
                        positionCount++;
                    }
                    
                    // Calculate average change across all positions
                    const averageChange = positionCount > 0 ? totalChange / positionCount : 0;
                    scoreChangesData.push(averageChange);
                }
                
                this.charts.scoreChanges.data = {
                    labels: stepLabels,
                    datasets: [{
                        data: scoreChangesData,
                        borderColor: '#ff6b6b',
                        backgroundColor: 'rgba(255, 107, 107, 0.1)',
                        pointRadius: 0,
                        pointHoverRadius: 4,
                        showLine: true,
                        tension: 0.4,
                        fill: false
                    }]
                };
                
                this.charts.scoreChanges.options.scales.x.title = {
                    display: true,
                    text: 'Step'
                };
                this.charts.scoreChanges.options.scales.y.title = {
                    display: true,
                    text: 'Average Score Change'
                };
                
                this.charts.scoreChanges.update('none');
            }
            
            updateChartProgress() {
                // Add current step indicator to charts
                if (!this.charts) return;
                
                Object.entries(this.charts).forEach(([key, chart]) => {
                    if (!chart || !chart.data || !chart.data.datasets || !Array.isArray(chart.data.datasets)) return;
                    
                    // Skip progress indicators for scoresDistribution and geneCorrelation charts
                    if (key === 'scoresDistribution' || key === 'geneCorrelation') {
                        return;
                    }
                    
                    // Remove existing progress indicator
                    const progressIndex = chart.data.datasets.findIndex(ds => ds.label === 'Current Step');
                    if (progressIndex !== -1) {
                        chart.data.datasets.splice(progressIndex, 1);
                    }
                    
                    // Theme-aware progress indicator colors
                    const progressColors = this.theme === 'dark' 
                        ? { border: '#ffffff', background: '#ffffff' }
                        : { border: '#212529', background: '#ffffff' };
                    
                    // Add progress indicator if we have data for the current step
                    if (chart.data.datasets[0] && chart.data.datasets[0].data && chart.data.datasets[0].data.length > this.currentStep) {
                        const currentData = chart.data.datasets[0].data[this.currentStep];
                        if (currentData !== undefined) {
                            chart.data.datasets.push({
                                label: 'Current Step',
                                type: 'scatter',
                                data: [{
                                    x: this.currentStep,
                                    y: currentData.y !== undefined ? currentData.y : currentData
                                }],
                                borderColor: progressColors.border,
                                backgroundColor: progressColors.background,
                                borderWidth: 2,
                                pointRadius: 6,
                                pointHoverRadius: 8,
                                showLine: false,
                                order: -1
                            });
                        }
                    }
                    
                    chart.update('none');
                });
            }
            
            setStep(step) {
                // Get max steps from available data
                let maxSteps = 0;
                
                // Check evaluation results
                if (this.data.evaluation_results?.all_steps_metrics) {
                    const method = this.currentPerfMethod === 'cosine' ? 'cosine_method' : 'score_matrix_method';
                    const allSteps = this.data.evaluation_results.all_steps_metrics[method];
                    if (allSteps) {
                        const stepKeys = this.sortStepKeys(Object.keys(allSteps).filter(key => key.startsWith('step_')));
                        maxSteps = Math.max(maxSteps, stepKeys.length - 1);
                    }
                }
                
                // Check method data
                if (this.data.method_score_matrix?.all_steps) {
                    const stepKeys = this.sortStepKeys(Object.keys(this.data.method_score_matrix.all_steps).filter(key => key.startsWith('step_')));
                    maxSteps = Math.max(maxSteps, stepKeys.length - 1);
                }
                
                if (this.data.method_cosine_similarity?.all_steps) {
                    const stepKeys = this.sortStepKeys(Object.keys(this.data.method_cosine_similarity.all_steps).filter(key => key.startsWith('step_')));
                    maxSteps = Math.max(maxSteps, stepKeys.length - 1);
                }
                
                // Update current step
                this.currentStep = Math.max(0, Math.min(step, maxSteps));
                this.elements.stepSlider.value = this.currentStep;
                this.updateStepInfo();
                
                // Update visualization for current step - this will trigger matrix updates
                this.updateVisualization();
                this.updatePerformanceMetrics();
                this.updateCharts();
                this.updateChartProgress();
            }
            
            updateStepInfo() {
                if (!this.data.evaluation_results?.all_steps_metrics) {
                    this.elements.stepInfo.textContent = 'Default noise level';
                    return;
                }
                
                const method = this.currentPerfMethod === 'cosine' ? 'cosine_method' : 'score_matrix_method';
                const allSteps = this.data.evaluation_results.all_steps_metrics[method];
                if (!allSteps) return;
                
                const stepKeys = this.sortStepKeys(Object.keys(allSteps).filter(key => key.startsWith('step_')));
                const currentStepKey = stepKeys[this.currentStep];
                const noiseLevel = allSteps[currentStepKey]?.noise_level;
                
                this.elements.stepInfo.textContent = `Noise Step: ${this.currentStep} / ${stepKeys.length - 1}`;
                if (noiseLevel !== undefined) {
                    this.elements.stepInfo.textContent += ` | σ: ${noiseLevel.toFixed(3)}`;
                }
            }
            
            togglePlay() {
                this.isPlaying = !this.isPlaying;
                
                if (this.isPlaying) {
                    this.elements.playIcon.textContent = '⏸';
                    this.play();
                } else {
                    this.elements.playIcon.textContent = '▶';
                    this.pause();
                }
            }
            
            play() {
                if (!this.data.evaluation_results?.all_steps_metrics) return;
                
                const speed = parseInt(this.elements.speedSlider.value);
                const interval = Math.max(100, 1000 / speed);
                
                const method = this.currentPerfMethod === 'cosine' ? 'cosine_method' : 'score_matrix_method';
                const allSteps = this.data.evaluation_results.all_steps_metrics[method];
                if (!allSteps) return;
                
                const stepKeys = this.sortStepKeys(Object.keys(allSteps).filter(key => key.startsWith('step_')));
                
                this.playInterval = setInterval(() => {
                    if (this.currentStep < stepKeys.length - 1) {
                        this.setStep(this.currentStep + 1);
                    } else {
                        this.togglePlay();
                    }
                }, interval);
            }
            
            pause() {
                if (this.playInterval) {
                    clearInterval(this.playInterval);
                    this.playInterval = null;
                }
            }
            
            updatePlaySpeed() {
                if (this.isPlaying) {
                    this.pause();
                    this.play();
                }
            }
            
            previousStep() {
                this.setStep(this.currentStep - 1);
            }
            
            nextStep() {
                this.setStep(this.currentStep + 1);
            }
        }
        
        // Initialize the VEP visualizer
        let app;
        document.addEventListener('DOMContentLoaded', () => {
            app = new VEPVisualizer();
        });
    </script>
</body>
</html>